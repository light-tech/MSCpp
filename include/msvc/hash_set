// hash_set extension header
#pragma once
#ifndef _HASH_SET_
#define _HASH_SET_
#ifndef RC_INVOKED
#include <xhash>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

#ifndef _SILENCE_STDEXT_HASH_DEPRECATION_WARNINGS
#error <hash_set> is deprecated and will be REMOVED. Please use <unordered_set>. You can define \
_SILENCE_STDEXT_HASH_DEPRECATION_WARNINGS to acknowledge that you have received this warning.
#endif // _SILENCE_STDEXT_HASH_DEPRECATION_WARNINGS

namespace stdext {
    using _STD allocator;
    using _STD swap;
    using _STD _Hash;
    using _STD _Is_nothrow_swappable;
    using _STD _Swap_adl;

    // CLASS TEMPLATE _Hset_traits
    template <class _Kty, // key type (same as value type)
        class _Tr, // comparator predicate type
        class _Alloc, // actual allocator type (should be value allocator)
        bool _Mfl> // true if multiple equivalent keys are permitted
    class _Hset_traits : public _Tr { // traits required to make _Hash behave like a set
    public:
        using key_type            = _Kty;
        using value_type          = _Kty;
        using _Mutable_value_type = _Kty;
        using key_compare         = _Tr;
        using allocator_type      = _Alloc;
#if _HAS_CXX17
        using node_type =
            _STD _Node_handle<_STD _List_node<value_type, typename _STD allocator_traits<_Alloc>::void_pointer>, _Alloc,
                _STD _Node_handle_set_base, _Kty>;
#endif // _HAS_CXX17

        static constexpr bool _Multi    = _Mfl;
        static constexpr bool _Standard = false;

        _Hset_traits(const _Tr& _Traits = _Tr())
            : _Tr(_Traits), _Max_buckets(0.0F) { // construct with specified comparator
        }

        using value_compare = key_compare;

        static const _Kty& _Kfn(const value_type& _Val) { // return entire value as key
            return _Val;
        }

        static int _Nonkfn(const value_type&) { // extract "non-key" from element value (for container equality)
            return 0;
        }

        float& _Get_max_bucket_size() noexcept { // return reference to current maximum bucket size
            return _Max_buckets;
        }

        const float& _Get_max_bucket_size() const noexcept { // return const reference to current maximum bucket size
            return _Max_buckets;
        }

        void swap(_Hset_traits& _Rhs) _NOEXCEPT_COND(_Is_nothrow_swappable<_Tr>::value) {
            _Swap_adl(static_cast<_Tr&>(*this), static_cast<_Tr&>(_Rhs));
            _STD swap(_Max_buckets, _Rhs._Max_buckets);
        }

        float _Max_buckets; // current maximum bucket size
    };

    // CLASS TEMPLATE hash_set
    template <class _Kty, class _Tr = hash_compare<_Kty, less<_Kty>>, class _Alloc = allocator<_Kty>>
    class hash_set : public _Hash<_Hset_traits<_Kty, _Tr, _Alloc, false>> { // hash table of key values, unique keys
    public:
        using _Mybase         = _Hash<_Hset_traits<_Kty, _Tr, _Alloc, false>>;
        using key_type        = _Kty;
        using key_compare     = _Tr;
        using value_compare   = typename _Mybase::value_compare;
        using value_type      = typename _Mybase::value_type;
        using allocator_type  = typename _Mybase::allocator_type;
        using size_type       = typename _Mybase::size_type;
        using difference_type = typename _Mybase::difference_type;
        using pointer         = typename _Mybase::pointer;
        using const_pointer   = typename _Mybase::const_pointer;
        using reference       = value_type&;
        using const_reference = const value_type&;
        using iterator        = typename _Mybase::iterator;
        using const_iterator  = typename _Mybase::const_iterator;
        using _Alnode         = typename _Mybase::_Alnode;
        using _Alnode_traits  = typename _Mybase::_Alnode_traits;
#if _HAS_CXX17
        using insert_return_type = _STD _Insert_return_type<iterator, typename _Mybase::node_type>;
#endif // _HAS_CXX17

        hash_set() : _Mybase(key_compare(), allocator_type()) { // construct empty set from defaults
        }

        explicit hash_set(const allocator_type& _Al)
            : _Mybase(key_compare(), _Al) { // construct empty set from defaults, allocator
        }

        hash_set(const hash_set& _Right)
            : _Mybase(_Right, _Alnode_traits::select_on_container_copy_construction(
                                  _Right._Getal())) { // construct set by copying _Right
        }

        hash_set(const hash_set& _Right, const allocator_type& _Al)
            : _Mybase(_Right, _Al) { // construct set by copying _Right, allocator
        }

        explicit hash_set(const key_compare& _Traits)
            : _Mybase(_Traits, allocator_type()) { // construct empty set from comparator
        }

        hash_set(const key_compare& _Traits, const allocator_type& _Al)
            : _Mybase(_Traits, _Al) { // construct empty set from comparator and allocator
        }

        template <class _Iter>
        hash_set(_Iter _First, _Iter _Last)
            : _Mybase(key_compare(), allocator_type()) { // construct set from sequence, defaults
            this->insert(_First, _Last);
        }

        template <class _Iter>
        hash_set(_Iter _First, _Iter _Last, const key_compare& _Traits)
            : _Mybase(_Traits, allocator_type()) { // construct set from sequence, comparator
            this->insert(_First, _Last);
        }

        template <class _Iter>
        hash_set(_Iter _First, _Iter _Last, const key_compare& _Traits, const allocator_type& _Al)
            : _Mybase(_Traits, _Al) { // construct set from sequence, comparator, and allocator
            this->insert(_First, _Last);
        }

        hash_set& operator=(const hash_set& _Right) { // assign by copying _Right
            _Mybase::operator=(_Right);
            return *this;
        }

        hash_set(hash_set&& _Right) : _Mybase(_STD move(_Right)) { // construct set by moving _Right
        }

        hash_set(hash_set&& _Right, const allocator_type& _Al)
            : _Mybase(_STD move(_Right), _Al) { // construct set by moving _Right, allocator
        }

        hash_set& operator=(hash_set&& _Right) { // assign by moving _Right
            _Mybase::operator=(_STD move(_Right));
            return *this;
        }

        void swap(hash_set& _Right) _NOEXCEPT_COND(noexcept(_Mybase::swap(_Right))) // strengthened
        { // exchange contents with non-movable _Right
            _Mybase::swap(_Right);
        }

        hash_set(_STD initializer_list<value_type> _Ilist)
            : _Mybase(key_compare(), allocator_type()) { // construct from initializer_list, defaults
            this->insert(_Ilist);
        }

        hash_set(_STD initializer_list<value_type> _Ilist, const key_compare& _Pred)
            : _Mybase(_Pred, allocator_type()) { // construct from initializer_list, comparator
            this->insert(_Ilist);
        }

        hash_set(_STD initializer_list<value_type> _Ilist, const key_compare& _Pred, const allocator_type& _Al)
            : _Mybase(_Pred, _Al) { // construct from initializer_list, comparator, and allocator
            this->insert(_Ilist);
        }

        hash_set& operator=(_STD initializer_list<value_type> _Ilist) { // assign initializer_list
            this->clear();
            this->insert(_Ilist);
            return *this;
        }

        using reverse_iterator       = _STD reverse_iterator<iterator>;
        using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

        reverse_iterator rbegin() noexcept { // return iterator for beginning of reversed mutable sequence
            return reverse_iterator(this->end());
        }

        const_reverse_iterator rbegin() const
            noexcept { // return iterator for beginning of reversed nonmutable sequence
            return const_reverse_iterator(this->end());
        }

        reverse_iterator rend() noexcept { // return iterator for end of reversed mutable sequence
            return reverse_iterator(this->begin());
        }

        const_reverse_iterator rend() const noexcept { // return iterator for end of reversed nonmutable sequence
            return const_reverse_iterator(this->begin());
        }

        const_reverse_iterator crbegin() const
            noexcept { // return iterator for beginning of reversed nonmutable sequence
            return rbegin();
        }

        const_reverse_iterator crend() const noexcept { // return iterator for end of reversed nonmutable sequence
            return rend();
        }

        using _Mybase::_Unchecked_begin;
        using _Mybase::_Unchecked_end;
    };

    template <class _Kty, class _Tr, class _Alloc>
    inline void swap(hash_set<_Kty, _Tr, _Alloc>& _Left, hash_set<_Kty, _Tr, _Alloc>& _Right)
        _NOEXCEPT_COND(noexcept(_Left.swap(_Right))) // strengthened
    { // swap _Left and _Right hash_sets
        _Left.swap(_Right);
    }

    template <class _Kty, class _Tr, class _Alloc>
    inline bool operator==(const hash_set<_Kty, _Tr, _Alloc>& _Left,
        const hash_set<_Kty, _Tr, _Alloc>& _Right) { // test for hash_set equality
        return _STD _Hash_equal(_Left, _Right);
    }

    template <class _Kty, class _Tr, class _Alloc>
    inline bool operator!=(const hash_set<_Kty, _Tr, _Alloc>& _Left,
        const hash_set<_Kty, _Tr, _Alloc>& _Right) { // test for hash_set inequality
        return !(_Left == _Right);
    }

    // CLASS TEMPLATE hash_multiset
    template <class _Kty, class _Tr = hash_compare<_Kty, less<_Kty>>, class _Alloc = allocator<_Kty>>
    class hash_multiset
        : public _Hash<_Hset_traits<_Kty, _Tr, _Alloc, true>> { // hash table of key values, non-unique keys
    public:
        using _Mybase         = _Hash<_Hset_traits<_Kty, _Tr, _Alloc, true>>;
        using key_type        = _Kty;
        using key_compare     = _Tr;
        using value_compare   = typename _Mybase::value_compare;
        using value_type      = typename _Mybase::value_type;
        using allocator_type  = typename _Mybase::allocator_type;
        using size_type       = typename _Mybase::size_type;
        using difference_type = typename _Mybase::difference_type;
        using pointer         = typename _Mybase::pointer;
        using const_pointer   = typename _Mybase::const_pointer;
        using reference       = value_type&;
        using const_reference = const value_type&;
        using iterator        = typename _Mybase::iterator;
        using const_iterator  = typename _Mybase::const_iterator;
        using _Alnode         = typename _Mybase::_Alnode;
        using _Alnode_traits  = typename _Mybase::_Alnode_traits;

        hash_multiset() : _Mybase(key_compare(), allocator_type()) { // construct empty set from defaults
        }

        explicit hash_multiset(const allocator_type& _Al)
            : _Mybase(key_compare(), _Al) { // construct empty set from defaults, allocator
        }

        hash_multiset(const hash_multiset& _Right)
            : _Mybase(_Right, _Alnode_traits::select_on_container_copy_construction(
                                  _Right._Getal())) { // construct set by copying _Right
        }

        hash_multiset(const hash_multiset& _Right, const allocator_type& _Al)
            : _Mybase(_Right, _Al) { // construct set by copying _Right, allocator
        }

        explicit hash_multiset(const key_compare& _Traits)
            : _Mybase(_Traits, allocator_type()) { // construct empty set from comparator
        }

        hash_multiset(const key_compare& _Traits, const allocator_type& _Al)
            : _Mybase(_Traits, _Al) { // construct empty set from comparator and allocator
        }

        template <class _Iter>
        hash_multiset(_Iter _First, _Iter _Last)
            : _Mybase(key_compare(), allocator_type()) { // construct from sequence, defaults
            this->insert(_First, _Last);
        }

        template <class _Iter>
        hash_multiset(_Iter _First, _Iter _Last, const key_compare& _Traits)
            : _Mybase(_Traits, allocator_type()) { // construct from sequence, comparator
            this->insert(_First, _Last);
        }

        template <class _Iter>
        hash_multiset(_Iter _First, _Iter _Last, const key_compare& _Traits, const allocator_type& _Al)
            : _Mybase(_Traits, _Al) { // construct from sequence, comparator, and allocator
            this->insert(_First, _Last);
        }

        hash_multiset& operator=(const hash_multiset& _Right) { // assign by copying _Right

            _Mybase::operator=(_Right);
            return *this;
        }

        hash_multiset(hash_multiset&& _Right) : _Mybase(_STD move(_Right)) { // construct set by moving _Right
        }

        hash_multiset(hash_multiset&& _Right, const allocator_type& _Al)
            : _Mybase(_STD move(_Right), _Al) { // construct set by moving _Right, allocator
        }

        hash_multiset& operator=(hash_multiset&& _Right) { // assign by moving _Right

            _Mybase::operator=(_STD move(_Right));
            return *this;
        }

        void swap(hash_multiset& _Right) _NOEXCEPT_COND(noexcept(_Mybase::swap(_Right))) // strengthened
        { // exchange contents with non-movable _Right
            _Mybase::swap(_Right);
        }

        hash_multiset(_STD initializer_list<value_type> _Ilist)
            : _Mybase(key_compare(), allocator_type()) { // construct from initializer_list, defaults
            this->insert(_Ilist);
        }

        hash_multiset(_STD initializer_list<value_type> _Ilist, const key_compare& _Pred)
            : _Mybase(_Pred, allocator_type()) { // construct from initializer_list, comparator
            this->insert(_Ilist);
        }

        hash_multiset(_STD initializer_list<value_type> _Ilist, const key_compare& _Pred, const allocator_type& _Al)
            : _Mybase(_Pred, _Al) { // construct from initializer_list, comparator, and allocator
            this->insert(_Ilist);
        }

        hash_multiset& operator=(_STD initializer_list<value_type> _Ilist) { // assign initializer_list
            this->clear();
            this->insert(_Ilist);
            return *this;
        }

        using reverse_iterator       = _STD reverse_iterator<iterator>;
        using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

        reverse_iterator rbegin() noexcept { // return iterator for beginning of reversed mutable sequence
            return reverse_iterator(this->end());
        }

        const_reverse_iterator rbegin() const
            noexcept { // return iterator for beginning of reversed nonmutable sequence
            return const_reverse_iterator(this->end());
        }

        reverse_iterator rend() noexcept { // return iterator for end of reversed mutable sequence
            return reverse_iterator(this->begin());
        }

        const_reverse_iterator rend() const noexcept { // return iterator for end of reversed nonmutable sequence
            return const_reverse_iterator(this->begin());
        }

        const_reverse_iterator crbegin() const
            noexcept { // return iterator for beginning of reversed nonmutable sequence
            return rbegin();
        }

        const_reverse_iterator crend() const noexcept { // return iterator for end of reversed nonmutable sequence
            return rend();
        }

        using _Mybase::_Unchecked_begin;
        using _Mybase::_Unchecked_end;
    };

    template <class _Kty, class _Tr, class _Alloc>
    inline void swap(hash_multiset<_Kty, _Tr, _Alloc>& _Left, hash_multiset<_Kty, _Tr, _Alloc>& _Right)
        _NOEXCEPT_COND(noexcept(_Left.swap(_Right))) // strengthened
    { // swap _Left and _Right hash_multisets
        _Left.swap(_Right);
    }

    template <class _Kty, class _Tr, class _Alloc>
    inline bool operator==(const hash_multiset<_Kty, _Tr, _Alloc>& _Left,
        const hash_multiset<_Kty, _Tr, _Alloc>& _Right) { // test for hash_multiset equality
        return _STD _Hash_equal(_Left, _Right);
    }

    template <class _Kty, class _Tr, class _Alloc>
    inline bool operator!=(const hash_multiset<_Kty, _Tr, _Alloc>& _Left,
        const hash_multiset<_Kty, _Tr, _Alloc>& _Right) { // test for hash_multiset inequality
        return !(_Left == _Right);
    }
} // namespace stdext
_STD_BEGIN
using stdext::hash_multiset;
using stdext::hash_set;
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // RC_INVOKED
#endif // _HASH_SET_

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
