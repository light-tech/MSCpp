// vector standard header
#pragma once
#ifndef _VECTOR_
#define _VECTOR_
#ifndef RC_INVOKED
#include <xmemory>

#if _HAS_CXX17
#include <xpolymorphic_allocator.h>
#endif // _HAS_CXX17

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
// CLASS TEMPLATE _Vector_const_iterator
template <class _Myvec>
class _Vector_const_iterator : public _Iterator_base { // iterator for nonmutable vector
public:
    using iterator_category = random_access_iterator_tag;

    using value_type      = typename _Myvec::value_type;
    using difference_type = typename _Myvec::difference_type;
    using pointer         = typename _Myvec::const_pointer;
    using reference       = const value_type&;
    using _Tptr           = typename _Myvec::pointer;

    _Vector_const_iterator() : _Ptr() { // construct with null pointer
    }

    _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) : _Ptr(_Parg) { // construct with pointer _Parg
        this->_Adopt(_Pvector);
    }

    _NODISCARD reference operator*() const { // return designated object
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
        _STL_VERIFY(
            _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return *_Ptr;
    }

    _NODISCARD pointer operator->() const { // return pointer to class object
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
        _STL_VERIFY(
            _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _Ptr;
    }

    _Vector_const_iterator& operator++() { // preincrement
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
        _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        ++_Ptr;
        return *this;
    }

    _Vector_const_iterator operator++(int) { // postincrement
        _Vector_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    _Vector_const_iterator& operator--() { // predecrement
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        _STL_VERIFY(_Ptr, "can't decrement value-initialized vector iterator");
        _STL_VERIFY(_Mycont->_Myfirst < _Ptr, "can't decrement vector iterator before begin");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        --_Ptr;
        return *this;
    }

    _Vector_const_iterator operator--(int) { // postdecrement
        _Vector_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    void _Verify_offset(const difference_type _Off) const {
#if _ITERATOR_DEBUG_LEVEL == 0
        (void) _Off;
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
        const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
        _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
        if (_Off < 0) {
            _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
        }

        if (_Off > 0) {
            _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
        }
#endif // _ITERATOR_DEBUG_LEVEL == 0
    }

    _Vector_const_iterator& operator+=(const difference_type _Off) { // increment by integer
        _Verify_offset(_Off);
        _Ptr += _Off;
        return *this;
    }

    _NODISCARD _Vector_const_iterator operator+(const difference_type _Off) const { // return this + integer
        _Vector_const_iterator _Tmp = *this;
        return _Tmp += _Off;
    }

    _Vector_const_iterator& operator-=(const difference_type _Off) { // decrement by integer
        return *this += -_Off;
    }

    _NODISCARD _Vector_const_iterator operator-(const difference_type _Off) const { // return this - integer
        _Vector_const_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }

    _NODISCARD difference_type operator-(const _Vector_const_iterator& _Right) const { // return difference of iterators
        _Compat(_Right);
        return _Ptr - _Right._Ptr;
    }

    _NODISCARD reference operator[](const difference_type _Off) const { // subscript
        return *(*this + _Off);
    }

    _NODISCARD bool operator==(const _Vector_const_iterator& _Right) const { // test for iterator equality
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }

    _NODISCARD bool operator!=(const _Vector_const_iterator& _Right) const { // test for iterator inequality
        return !(*this == _Right);
    }

    _NODISCARD bool operator<(const _Vector_const_iterator& _Right) const { // test if this < _Right
        _Compat(_Right);
        return _Ptr < _Right._Ptr;
    }

    _NODISCARD bool operator>(const _Vector_const_iterator& _Right) const { // test if this > _Right
        return _Right < *this;
    }

    _NODISCARD bool operator<=(const _Vector_const_iterator& _Right) const { // test if this <= _Right
        return !(_Right < *this);
    }

    _NODISCARD bool operator>=(const _Vector_const_iterator& _Right) const { // test if this >= _Right
        return !(*this < _Right);
    }

    void _Compat(const _Vector_const_iterator& _Right) const { // test for compatible iterator pair
#if _ITERATOR_DEBUG_LEVEL == 0
        (void) _Right;
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
        _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL == 0
    }

#if _ITERATOR_DEBUG_LEVEL != 0
    friend void _Verify_range(const _Vector_const_iterator& _First, const _Vector_const_iterator& _Last) {
        _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "vector iterators in range are from different containers");
        _STL_VERIFY(_First._Ptr <= _Last._Ptr, "vector iterator range transposed");
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0

    using _Prevent_inheriting_unwrap = _Vector_const_iterator;

    _NODISCARD pointer _Unwrapped() const {
        return _Ptr;
    }

    void _Seek_to(pointer _It) {
        _Ptr = _Const_cast(_It);
    }

    _Tptr _Ptr; // pointer to element in vector
};

template <class _Myvec>
_NODISCARD inline _Vector_const_iterator<_Myvec> operator+(
    typename _Vector_const_iterator<_Myvec>::difference_type _Off,
    _Vector_const_iterator<_Myvec> _Next) { // add offset to iterator
    return _Next += _Off;
}

// CLASS TEMPLATE _Vector_iterator
template <class _Myvec>
class _Vector_iterator : public _Vector_const_iterator<_Myvec> { // iterator for mutable vector
public:
    using _Mybase           = _Vector_const_iterator<_Myvec>;
    using iterator_category = random_access_iterator_tag;

    using value_type      = typename _Myvec::value_type;
    using difference_type = typename _Myvec::difference_type;
    using pointer         = typename _Myvec::pointer;
    using reference       = value_type&;

    _Vector_iterator() { // construct with null vector pointer
    }

    _Vector_iterator(pointer _Parg, const _Container_base* _Pvector)
        : _Mybase(_Parg, _Pvector) { // construct with pointer _Parg
    }

    _NODISCARD reference operator*() const { // return designated object
        return const_cast<reference>(_Mybase::operator*());
    }

    _NODISCARD pointer operator->() const { // return pointer to class object
        return _Const_cast(_Mybase::operator->());
    }

    _Vector_iterator& operator++() { // preincrement
        ++*(_Mybase*) this;
        return *this;
    }

    _Vector_iterator operator++(int) { // postincrement
        _Vector_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    _Vector_iterator& operator--() { // predecrement
        --*(_Mybase*) this;
        return *this;
    }

    _Vector_iterator operator--(int) { // postdecrement
        _Vector_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    _Vector_iterator& operator+=(const difference_type _Off) { // increment by integer
        *(_Mybase*) this += _Off;
        return *this;
    }

    _NODISCARD _Vector_iterator operator+(const difference_type _Off) const { // return this + integer
        _Vector_iterator _Tmp = *this;
        return _Tmp += _Off;
    }

    _Vector_iterator& operator-=(const difference_type _Off) { // decrement by integer
        return *this += -_Off;
    }

    _NODISCARD _Vector_iterator operator-(const difference_type _Off) const { // return this - integer
        _Vector_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }

    _NODISCARD difference_type operator-(const _Mybase& _Right) const { // return difference of iterators
        return *(_Mybase*) this - _Right;
    }

    _NODISCARD reference operator[](const difference_type _Off) const { // subscript
        return *(*this + _Off);
    }

    using _Prevent_inheriting_unwrap = _Vector_iterator;

    _NODISCARD pointer _Unwrapped() const {
        return this->_Ptr;
    }
};

template <class _Myvec>
_NODISCARD inline _Vector_iterator<_Myvec> operator+(typename _Vector_iterator<_Myvec>::difference_type _Off,
    _Vector_iterator<_Myvec> _Next) { // add offset to iterator
    return _Next += _Off;
}

// vector TYPE WRAPPERS
template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Reference,
    class _Const_reference>
struct _Vec_iter_types { // wraps types needed by iterators
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};

// STRUCT _Value_init_tag
struct _Value_init_tag { // tag to request value-initialization
};

// CLASS TEMPLATE _Vector_val
template <class _Val_types>
class _Vector_val : public _Container_base { // base class for vector to hold data
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values
    }

    pointer _Myfirst; // pointer to beginning of array
    pointer _Mylast; // pointer to current end of sequence
    pointer _Myend; // pointer to end of array
};

// FUNCTION TEMPLATE _Unfancy_maybe_null
template <class _Ptrty>
inline auto _Unfancy_maybe_null(_Ptrty _Ptr) { // converts from a (potentially null) fancy pointer to a plain pointer
    return _Ptr ? _STD addressof(*_Ptr) : nullptr;
}

template <class _Ty>
inline _Ty* _Unfancy_maybe_null(_Ty* _Ptr) { // do nothing for plain pointers
    return _Ptr;
}

// CLASS TEMPLATE vector
template <class _Ty, class _Alloc = allocator<_Ty>>
class vector { // varying size array of values
private:
    template <class>
    friend class _Vb_val;
    friend _Tidy_guard<vector>;
    template <class>
    friend class _Hash;

    using _Alty        = _Rebind_alloc_t<_Alloc, _Ty>;
    using _Alty_traits = allocator_traits<_Alty>;

    using _Scary_val = _Vector_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Ty>,
        _Vec_iter_types<_Ty, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Ty&, const _Ty&>>>;

public:
    static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Ty, typename _Alloc::value_type>,
        _MISMATCHED_ALLOCATOR_MESSAGE("vector<T, Allocator>", "T"));

    using value_type             = _Ty;
    using allocator_type         = _Alloc;
    using pointer                = typename _Alty_traits::pointer;
    using const_pointer          = typename _Alty_traits::const_pointer;
    using reference              = _Ty&;
    using const_reference        = const _Ty&;
    using size_type              = typename _Alty_traits::size_type;
    using difference_type        = typename _Alty_traits::difference_type;
    using iterator               = _Vector_iterator<_Scary_val>;
    using const_iterator         = _Vector_const_iterator<_Scary_val>;
    using reverse_iterator       = _STD reverse_iterator<iterator>;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

    vector() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Alty>)
        : _Mypair(_Zero_then_variadic_args_t()) { // construct empty vector
        _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
    }

    explicit vector(const _Alloc& _Al) noexcept
        : _Mypair(_One_then_variadic_args_t(), _Al) { // construct empty vector, allocator
        _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
    }

private:
    template <class _Ty2>
    void _Construct_n_copies_of_ty(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty2& _Val) {
        auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        if (_Count != 0) {
            _Buy_nonzero(_Count);
            _Tidy_guard<vector> _Guard{this};
            _Mylast()      = _Ufill(_Myfirst(), _Count, _Val);
            _Guard._Target = nullptr;
        }

        _Proxy._Release();
    }

public:
    explicit vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Count * _Ty(), optional allocator
        _Construct_n_copies_of_ty(_Count, _Value_init_tag{});
    }

    vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty& _Val, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Count * _Val, optional allocator
        _Construct_n_copies_of_ty(_Count, _Val);
    }

private:
    template <class _Any_alloc>
    vector(_Move_allocator_tag, _CRT_GUARDOVERFLOW const size_type _Count, const _Ty& _Val, _Any_alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _STD move(_Al)) { // construct from _Count * _Val, moved-from allocator
        _Construct_n_copies_of_ty(_Count, _Val);
    }

    template <class _Iter>
    void _Range_construct_or_tidy(_Iter _First, _Iter _Last,
        input_iterator_tag) { // initialize with [_First, _Last), avoid leaking, input iterators
        _Tidy_guard<vector> _Guard{this};
        for (; _First != _Last; ++_First) {
            emplace_back(*_First); // performance note: emplace_back()'s strong guarantee is unnecessary here
        }

        _Guard._Target = nullptr;
    }

    template <class _Iter>
    void _Range_construct_or_tidy(_Iter _First, _Iter _Last,
        forward_iterator_tag) { // initialize with [_First, _Last), avoid leaking, forward iterators
        const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
        if (_Count != 0) {
            _Buy_nonzero(_Count);
            _Tidy_guard<vector> _Guard{this};
            _Mylast()      = _Ucopy(_First, _Last, _Myfirst());
            _Guard._Target = nullptr;
        }
    }

public:
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from [_First, _Last) with optional allocator
        auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Adl_verify_range(_First, _Last);
        _Range_construct_or_tidy(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
        _Proxy._Release();
    }

    vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from initializer_list, optional allocator
        auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
        _Proxy._Release();
    }

    vector(const vector& _Right)
        : _Mypair(_One_then_variadic_args_t(),
              _Alty_traits::select_on_container_copy_construction(_Right._Getal())) { // construct by copying _Right
        auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        if (!_Right.empty()) {
            _Buy_raw(_Right.size());
            _Tidy_guard<vector> _Guard{this};
            _Mylast()      = _Ucopy(_Right._Myfirst(), _Right._Mylast(), _Myfirst());
            _Guard._Target = nullptr;
        }

        _Proxy._Release();
    }

    vector(const vector& _Right, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al) { // construct by copying _Right, allocator
        auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        if (!_Right.empty()) {
            _Buy_raw(_Right.size());
            _Tidy_guard<vector> _Guard{this};
            _Mylast()      = _Ucopy(_Right._Myfirst(), _Right._Mylast(), _Myfirst());
            _Guard._Target = nullptr;
        }

        _Proxy._Release();
    }

private:
    void _Take_contents(vector& _Right) noexcept {
        auto& _My_data    = _Get_data();
        auto& _Right_data = _Right._Get_data();
        _My_data._Swap_proxy_and_iterators(_Right_data);

        _My_data._Myfirst = _Right_data._Myfirst;
        _My_data._Mylast  = _Right_data._Mylast;
        _My_data._Myend   = _Right_data._Myend;

        _Right_data._Myfirst = pointer();
        _Right_data._Mylast  = pointer();
        _Right_data._Myend   = pointer();
    }

    // _Move_from is an abi zombie name
    void _Move_construct(vector& _Right, true_type) noexcept { // move from _Right, stealing its contents
        _Take_contents(_Right);
    }

    void _Move_construct(vector& _Right, false_type) { // move from _Right, possibly moving its contents
        if
            _CONSTEXPR_IF(!_Alty_traits::is_always_equal::value) {
                if (_Getal() != _Right._Getal()) {
                    if (!_Right.empty()) {
                        _Buy_raw(_Right.size());
                        _Tidy_guard<vector> _Guard{this};
                        _Mylast()      = _Umove(_Right._Myfirst(), _Right._Mylast(), _Myfirst());
                        _Guard._Target = nullptr;
                    }
                    return;
                }
            }

        _Move_construct(_Right, true_type{});
    }

public:
    vector(vector&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) { // construct by moving _Right
        _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
        _Move_construct(_Right, true_type{});
    }

    vector(vector&& _Right, const _Alloc& _Al) _NOEXCEPT_COND(_Alty_traits::is_always_equal::value) // strengthened
        : _Mypair(_One_then_variadic_args_t(), _Al) { // construct by moving _Right, allocator
        auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
        _Move_construct(_Right, typename _Alty_traits::is_always_equal::type{});
        _Proxy._Release();
    }

private:
    void _Move_assign(vector& _Right, _Equal_allocators) noexcept {
        _Tidy();
        _Pocma(_Getal(), _Right._Getal());
        _Take_contents(_Right);
    }

    void _Move_assign(vector& _Right, _Propagate_allocators) noexcept {
        _Tidy();
#if _ITERATOR_DEBUG_LEVEL != 0
        if (_Getal() != _Right._Getal()) {
            // intentionally slams into noexcept on OOM, TRANSITION, VSO#466800
            _Get_data()._Reload_proxy(
                _GET_PROXY_ALLOCATOR(_Alty, _Getal()), _GET_PROXY_ALLOCATOR(_Alty, _Right._Getal()));
        }
#endif

        _Pocma(_Getal(), _Right._Getal());
        _Take_contents(_Right);
    }

    void _Move_assign(vector& _Right, _No_propagate_allocators) {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            const pointer _First     = _Right._Myfirst();
            const pointer _Last      = _Right._Mylast();
            const size_type _Newsize = _Right.size();

            _Orphan_all();

#if _HAS_IF_CONSTEXPR
            if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Ty*, _Ty*>::_Trivially_copyable>,
                              _Uses_default_construct<_Alty, _Ty*, _Ty>, _Uses_default_destroy<_Alty, _Ty*>>) {
                if (_Newsize > capacity()) {
                    _Clear_and_reserve_geometric(_Newsize);
                }

                _Mylast() = _Refancy<pointer>(_Copy_memmove(_Unfancy(_First), _Unfancy(_Last), _Unfancy(_Myfirst())));
            } else
#endif // _HAS_IF_CONSTEXPR
            {
                size_type _Oldsize = size();

                if (_Newsize > _Oldsize) {
                    if (_Newsize > capacity()) { // reallocate
                        _Clear_and_reserve_geometric(_Newsize);
                        _Oldsize = 0;
                    }

                    const pointer _Mid = _First + _Oldsize;
                    _Move_unchecked(_First, _Mid, _Myfirst());
                    _Mylast() = _Umove(_Mid, _Last, _Mylast());
                } else {
                    const pointer _Newlast = _Myfirst() + _Newsize;
                    _Move_unchecked(_First, _Last, _Myfirst());
                    _Destroy(_Newlast, _Mylast());
                    _Mylast() = _Newlast;
                }
            }
        }
    }

public:
    vector& operator=(vector&& _Right) _NOEXCEPT_COND(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {
        if (this != _STD addressof(_Right)) {
            _Move_assign(_Right, _Choose_pocma<_Alty>{});
        }

        return *this;
    }

    ~vector() noexcept { // destroy the object
        _Tidy();
#if _ITERATOR_DEBUG_LEVEL != 0
        auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Delete_plain(_Alproxy, _STD exchange(_Myproxy(), nullptr));
#endif // _ITERATOR_DEBUG_LEVEL != 0
    }

private:
    template <class... _Valty>
    decltype(auto) _Emplace_back_with_unused_capacity(
        _Valty&&... _Val) { // insert by perfectly forwarding into element at end, provide strong guarantee
                            // pre: _Has_unused_capacity()
        _Alty_traits::construct(_Getal(), _Unfancy(_Mylast()), _STD forward<_Valty>(_Val)...);
        _Orphan_range(_Mylast(), _Mylast());
        _Ty& _Result = *_Mylast();
        ++_Mylast();
#if _HAS_CXX17
        return _Result;
#else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
        (void) _Result;
#endif // _HAS_CXX17
    }

public:
    template <class... _Valty>
    decltype(auto) emplace_back(
        _Valty&&... _Val) { // insert by perfectly forwarding into element at end, provide strong guarantee
        if (_Has_unused_capacity()) {
            return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
        }

        _Ty& _Result = *_Emplace_reallocate(_Mylast(), _STD forward<_Valty>(_Val)...);
#if _HAS_CXX17
        return _Result;
#else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
        (void) _Result;
#endif // _HAS_CXX17
    }

    void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee
        emplace_back(_Val);
    }

    void push_back(_Ty&& _Val) { // insert by moving into element at end, provide strong guarantee
        emplace_back(_STD move(_Val));
    }

    template <class... _Valty>
    pointer _Emplace_reallocate(
        const pointer _Whereptr, _Valty&&... _Val) { // reallocate and insert by perfectly forwarding _Val at _Whereptr
                                                     // pre: !_Has_unused_capacity()
        const size_type _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst());
        _Alty& _Al                = _Getal();
        const size_type _Oldsize  = size();

        if (_Oldsize == max_size()) {
            _Xlength();
        }

        const size_type _Newsize     = _Oldsize + 1;
        const size_type _Newcapacity = _Calculate_growth(_Newsize);

        const pointer _Newvec           = _Al.allocate(_Newcapacity);
        const pointer _Constructed_last = _Newvec + _Whereoff + 1;
        pointer _Constructed_first      = _Constructed_last;

        _TRY_BEGIN
        _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);
        _Constructed_first = _Newvec + _Whereoff;

        if (_Whereptr == _Mylast()) { // at back, provide strong guarantee
            _Umove_if_noexcept(_Myfirst(), _Mylast(), _Newvec);
        } else { // provide basic guarantee
            _Umove(_Myfirst(), _Whereptr, _Newvec);
            _Constructed_first = _Newvec;
            _Umove(_Whereptr, _Mylast(), _Newvec + _Whereoff + 1);
        }
        _CATCH_ALL
        _Destroy(_Constructed_first, _Constructed_last);
        _Al.deallocate(_Newvec, _Newcapacity);
        _RERAISE;
        _CATCH_END

        _Change_array(_Newvec, _Newsize, _Newcapacity);
        return this->_Myfirst() + _Whereoff;
    }

    template <class... _Valty>
    iterator emplace(const_iterator _Where, _Valty&&... _Val) { // insert by perfectly forwarding _Val at _Where
        const pointer _Whereptr = _Where._Ptr;
        const pointer _Oldlast  = _Mylast();
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(
            _Where._Getcont() == _STD addressof(_Get_data()) && _Whereptr >= _Myfirst() && _Oldlast >= _Whereptr,
            "vector emplace iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        if (_Has_unused_capacity()) {
            if (_Whereptr == _Oldlast) { // at back, provide strong guarantee
                _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
            } else {
                _Ty _Obj(_STD forward<_Valty>(_Val)...); // handle aliasing
                // after constructing _Obj, provide basic guarantee
                _Orphan_range(_Whereptr, _Oldlast);
                _Alty_traits::construct(_Getal(), _Unfancy(_Oldlast), _STD move(_Oldlast[-1]));
                ++_Mylast();
                _Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);
                *_Whereptr = _STD move(_Obj);
            }

            return _Make_iterator(_Whereptr);
        }

        return _Make_iterator(_Emplace_reallocate(_Whereptr, _STD forward<_Valty>(_Val)...));
    }

    iterator insert(const_iterator _Where, const _Ty& _Val) { // insert _Val at _Where
        return emplace(_Where, _Val);
    }

    iterator insert(const_iterator _Where, _Ty&& _Val) { // insert by moving _Val at _Where
        return emplace(_Where, _STD move(_Val));
    }

    iterator insert(const_iterator _Where, _CRT_GUARDOVERFLOW const size_type _Count,
        const _Ty& _Val) { // insert _Count * _Val at _Where
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(
            _Where._Getcont() == _STD addressof(_Get_data()) && _Where._Ptr >= _Myfirst() && _Mylast() >= _Where._Ptr,
            "vector insert iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        const size_type _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst());
        const bool _One_at_back   = _Count == 1 && _Where._Ptr == _Mylast();

        if (_Count == 0) { // nothing to do, avoid invalidating iterators
        } else if (_Count > _Unused_capacity()) { // reallocate
            const size_type _Oldsize = size();

            if (_Count > max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize     = _Oldsize + _Count;
            const size_type _Newcapacity = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Getal().allocate(_Newcapacity);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first      = _Constructed_last;

            _TRY_BEGIN
            _Ufill(_Newvec + _Whereoff, _Count, _Val);
            _Constructed_first = _Newvec + _Whereoff;

            if (_One_at_back) { // provide strong guarantee
                _Umove_if_noexcept(_Myfirst(), _Mylast(), _Newvec);
            } else { // provide basic guarantee
                _Umove(_Myfirst(), _Where._Ptr, _Newvec);
                _Constructed_first = _Newvec;
                _Umove(_Where._Ptr, _Mylast(), _Newvec + _Whereoff + _Count);
            }
            _CATCH_ALL
            _Destroy(_Constructed_first, _Constructed_last);
            _Getal().deallocate(_Newvec, _Newcapacity);
            _RERAISE;
            _CATCH_END

            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else if (_One_at_back) { // provide strong guarantee
            _Emplace_back_with_unused_capacity(_Val);
        } else { // provide basic guarantee
            const _Ty _Tmp                     = _Val; // handle aliasing
            const pointer _Oldlast             = _Mylast();
            const size_type _Affected_elements = static_cast<size_type>(_Oldlast - _Where._Ptr);
            _Orphan_range(_Where._Ptr, _Oldlast);

            if (_Count > _Affected_elements) { // new stuff spills off end
                _Mylast() = _Ufill(_Oldlast, _Count - _Affected_elements, _Tmp);
                _Mylast() = _Umove(_Where._Ptr, _Oldlast, _Mylast());
                _Fill_unchecked(_Where._Ptr, _Oldlast, _Tmp);
            } else { // new stuff can all be assigned
                _Mylast() = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
                _Move_backward_unchecked(_Where._Ptr, _Oldlast - _Count, _Oldlast);
                _Fill_unchecked(_Where._Ptr, _Where._Ptr + _Count, _Tmp);
            }
        }

        return _Make_iterator_offset(_Whereoff);
    }

private:
    template <class _Iter>
    void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last,
        input_iterator_tag) { // insert [_First, _Last) at _Where, input iterators
        if (_First == _Last) {
            return; // nothing to do, avoid invalidating iterators
        }

        const size_type _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst());
        const size_type _Oldsize  = size();

        // For one-at-back, provide strong guarantee.
        // Otherwise, provide basic guarantee (despite N4659 26.3.11.5 [vector.modifiers]/1).
        // Performance note: except for one-at-back, emplace_back()'s strong guarantee is unnecessary here.

        for (; _First != _Last; ++_First) {
            emplace_back(*_First);
        }

        _Orphan_range(_Myfirst() + _Whereoff, _Myfirst() + _Oldsize);

        _STD rotate(_Myfirst() + _Whereoff, _Myfirst() + _Oldsize, _Mylast());
    }

    template <class _Iter>
    void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last,
        forward_iterator_tag) { // insert [_First, _Last) at _Where, forward iterators
        const size_type _Count    = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
        const size_type _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst());
        const bool _One_at_back   = _Count == 1 && _Where._Ptr == _Mylast();

        if (_Count == 0) { // nothing to do, avoid invalidating iterators
        } else if (_Count > _Unused_capacity()) { // reallocate
            const size_type _Oldsize = size();

            if (_Count > max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize     = _Oldsize + _Count;
            const size_type _Newcapacity = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Getal().allocate(_Newcapacity);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first      = _Constructed_last;

            _TRY_BEGIN
            _Ucopy(_First, _Last, _Newvec + _Whereoff);
            _Constructed_first = _Newvec + _Whereoff;

            if (_One_at_back) { // provide strong guarantee
                _Umove_if_noexcept(_Myfirst(), _Mylast(), _Newvec);
            } else { // provide basic guarantee
                _Umove(_Myfirst(), _Where._Ptr, _Newvec);
                _Constructed_first = _Newvec;
                _Umove(_Where._Ptr, _Mylast(), _Newvec + _Whereoff + _Count);
            }
            _CATCH_ALL
            _Destroy(_Constructed_first, _Constructed_last);
            _Getal().deallocate(_Newvec, _Newcapacity);
            _RERAISE;
            _CATCH_END

            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else { // Attempt to provide the strong guarantee for EmplaceConstructible failure.
                 // If we encounter copy/move construction/assignment failure, provide the basic guarantee.
                 // (For one-at-back, this provides the strong guarantee.)

            const pointer _Oldlast             = _Mylast();
            const size_type _Affected_elements = static_cast<size_type>(_Oldlast - _Where._Ptr);

            if (_Count < _Affected_elements) { // some affected elements must be assigned
                _Mylast() = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
                _Move_backward_unchecked(_Where._Ptr, _Oldlast - _Count, _Oldlast);
                _Destroy(_Where._Ptr, _Where._Ptr + _Count);

                _TRY_BEGIN
                _Ucopy(_First, _Last, _Where._Ptr);
                _CATCH_ALL
                // glue the broken pieces back together

                _TRY_BEGIN
                _Umove(_Where._Ptr + _Count, _Where._Ptr + 2 * _Count, _Where._Ptr);
                _CATCH_ALL
                // vaporize the detached piece
                _Orphan_range(_Where._Ptr, _Oldlast);
                _Destroy(_Where._Ptr + _Count, _Mylast());
                _Mylast() = _Where._Ptr;
                _RERAISE;
                _CATCH_END

                _Move_unchecked(_Where._Ptr + 2 * _Count, _Mylast(), _Where._Ptr + _Count);
                _Destroy(_Oldlast, _Mylast());
                _Mylast() = _Oldlast;
                _RERAISE;
                _CATCH_END
            } else { // affected elements don't overlap before/after
                const pointer _Relocated = _Where._Ptr + _Count;
                _Mylast()                = _Umove(_Where._Ptr, _Oldlast, _Relocated);
                _Destroy(_Where._Ptr, _Oldlast);

                _TRY_BEGIN
                _Ucopy(_First, _Last, _Where._Ptr);
                _CATCH_ALL
                // glue the broken pieces back together

                _TRY_BEGIN
                _Umove(_Relocated, _Mylast(), _Where._Ptr);
                _CATCH_ALL
                // vaporize the detached piece
                _Orphan_range(_Where._Ptr, _Oldlast);
                _Destroy(_Relocated, _Mylast());
                _Mylast() = _Where._Ptr;
                _RERAISE;
                _CATCH_END

                _Destroy(_Relocated, _Mylast());
                _Mylast() = _Oldlast;
                _RERAISE;
                _CATCH_END
            }

            _Orphan_range(_Where._Ptr, _Oldlast);
        }
    }

public:
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) { // insert [_First, _Last) at _Where
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(
            _Where._Getcont() == _STD addressof(_Get_data()) && _Where._Ptr >= _Myfirst() && _Mylast() >= _Where._Ptr,
            "vector insert iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        _Adl_verify_range(_First, _Last);
        const size_type _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst());
        _Insert_range(_Where, _Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
        return _Make_iterator_offset(_Whereoff);
    }

    iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist) { // insert initializer_list at _Where
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }

    void assign(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty& _Val) { // assign _Newsize * _Val
        _Orphan_all();

        size_type _Oldsize = size();

        if (_Newsize > _Oldsize) {
            if (_Newsize > capacity()) { // reallocate
                _Clear_and_reserve_geometric(_Newsize);
                _Oldsize = 0;
            } else {
                _Fill_unchecked(_Myfirst(), _Mylast(), _Val);
            }

            _Mylast() = _Ufill(_Mylast(), _Newsize - _Oldsize, _Val);
        } else {
            const pointer _Newlast = _Myfirst() + _Newsize;
            _Fill_unchecked(_Myfirst(), _Newlast, _Val);
            _Destroy(_Newlast, _Mylast());
            _Mylast() = _Newlast;
        }
    }

private:
    template <class _Iter>
    void _Assign_range(_Iter _First, _Iter _Last, input_iterator_tag) { // assign [_First, _Last), input iterators
        _Orphan_all();

        pointer _Next = _Myfirst();

        for (; _First != _Last && _Next != _Mylast(); ++_First, (void) ++_Next) {
            *_Next = *_First;
        }

        // Code size optimization: we've exhausted only the source, only the dest, or both.
        // If we've exhausted only the source: we Trim, then Append does nothing.
        // If we've exhausted only the dest: Trim does nothing, then we Append.
        // If we've exhausted both: Trim does nothing, then Append does nothing.

        // Trim.
        _Destroy(_Next, _Mylast());
        _Mylast() = _Next;

        // Append.
        for (; _First != _Last; ++_First) {
            emplace_back(*_First); // performance note: emplace_back()'s strong guarantee is unnecessary here
        }
    }

    template <class _Iter>
    void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) { // assign [_First, _Last), forward iterators
        const size_type _Newsize = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));

        _Orphan_all();

#if _HAS_IF_CONSTEXPR
        if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Iter, _Ty*>::_Trivially_copyable>,
                          _Uses_default_construct<_Alty, _Ty*, decltype(*_First)>,
                          _Uses_default_destroy<_Alty, _Ty*>>) {
            if (_Newsize > capacity()) {
                _Clear_and_reserve_geometric(_Newsize);
            }

            _Mylast() = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst())));
        } else
#endif // _HAS_IF_CONSTEXPR
        {
            size_type _Oldsize = size();

            if (_Newsize > _Oldsize) {
                if (_Newsize > capacity()) { // reallocate
                    _Clear_and_reserve_geometric(_Newsize);
                    _Oldsize = 0;
                }

                // performance note: traversing [_First, _Mid) twice
                const _Iter _Mid = _STD next(_First, static_cast<difference_type>(_Oldsize));
                _Copy_unchecked(_First, _Mid, _Myfirst());
                _Mylast() = _Ucopy(_Mid, _Last, _Mylast());
            } else {
                const pointer _Newlast = _Myfirst() + _Newsize;
                _Copy_unchecked(_First, _Last, _Myfirst());
                _Destroy(_Newlast, _Mylast());
                _Mylast() = _Newlast;
            }
        }
    }

public:
    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    void assign(_Iter _First, _Iter _Last) { // assign [_First, _Last)
        _Adl_verify_range(_First, _Last);
        _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
    }

    void assign(initializer_list<_Ty> _Ilist) { // assign initializer_list
        _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
    }

private:
    void _Copy_assign(const vector& _Right, false_type) {
        _Pocca(_Getal(), _Right._Getal());
        assign(_Right._Myfirst(), _Right._Mylast());
    }

    void _Copy_assign(const vector& _Right, true_type) {
        if (_Getal() != _Right._Getal()) {
            _Tidy();
            _Get_data()._Reload_proxy(
                _GET_PROXY_ALLOCATOR(_Alty, _Getal()), _GET_PROXY_ALLOCATOR(_Alty, _Right._Getal()));
        }

        _Copy_assign(_Right, false_type{});
    }

public:
    vector& operator=(const vector& _Right) { // assign _Right
        if (this != _STD addressof(_Right)) { // different, assign it
            _Copy_assign(_Right, _Choose_pocca<_Alty>{});
        }

        return *this;
    }

    vector& operator=(initializer_list<_Ty> _Ilist) { // assign initializer_list
        _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
        return *this;
    }

private:
    template <class _Ty2>
    void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {
        if (_Newsize > max_size()) {
            _Xlength();
        }

        const size_type _Oldsize     = size();
        const size_type _Newcapacity = _Calculate_growth(_Newsize);

        const pointer _Newvec         = _Getal().allocate(_Newcapacity);
        const pointer _Appended_first = _Newvec + _Oldsize;
        pointer _Appended_last        = _Appended_first;

        _TRY_BEGIN
        _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);
        _Umove_if_noexcept(_Myfirst(), _Mylast(), _Newvec);
        _CATCH_ALL
        _Destroy(_Appended_first, _Appended_last);
        _Getal().deallocate(_Newvec, _Newcapacity);
        _RERAISE;
        _CATCH_END

        _Change_array(_Newvec, _Newsize, _Newcapacity);
    }

    template <class _Ty2>
    void _Resize(const size_type _Newsize, const _Ty2& _Val) { // trim or append elements, provide strong guarantee
        const size_type _Oldsize = size();
        if (_Newsize < _Oldsize) { // trim
            const pointer _Newlast = _Myfirst() + _Newsize;
            _Orphan_range(_Newlast, _Mylast());
            _Destroy(_Newlast, _Mylast());
            _Mylast() = _Newlast;
            return;
        }

        if (_Newsize > _Oldsize) { // append
            if (_Newsize > capacity()) { // reallocate
                _Resize_reallocate(_Newsize, _Val);
                return;
            }

            const pointer _Oldlast = _Mylast();
            _Mylast()              = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);
            _Orphan_range(_Oldlast, _Oldlast);
        }

        // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
    }

public:
    void resize(_CRT_GUARDOVERFLOW const size_type
            _Newsize) { // trim or append value-initialized elements, provide strong guarantee
        _Resize(_Newsize, _Value_init_tag{});
    }

    void resize(_CRT_GUARDOVERFLOW const size_type _Newsize,
        const _Ty& _Val) { // trim or append copies of _Val, provide strong guarantee
        _Resize(_Newsize, _Val);
    }

private:
    void _Reallocate_exactly(const size_type
            _Newcapacity) { // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
        const size_type _Size = size();

        const pointer _Newvec = _Getal().allocate(_Newcapacity);

        _TRY_BEGIN
        _Umove_if_noexcept(_Myfirst(), _Mylast(), _Newvec);
        _CATCH_ALL
        _Getal().deallocate(_Newvec, _Newcapacity);
        _RERAISE;
        _CATCH_END

        _Change_array(_Newvec, _Size, _Newcapacity);
    }

    void _Clear_and_reserve_geometric(const size_type _Newsize) { // pre: _Newsize != 0
                                                                  // pre: All iterators are orphaned
        if (_Newsize > max_size()) {
            _Xlength();
        }

        const size_type _Newcapacity = _Calculate_growth(_Newsize);
        auto& _My_data               = _Get_data();
        if (_My_data._Myfirst != pointer()) { // destroy and deallocate old array
            _Destroy(_My_data._Myfirst, _My_data._Mylast);
            _Getal().deallocate(_My_data._Myfirst, static_cast<size_type>(_My_data._Myend - _My_data._Myfirst));

            _My_data._Myfirst = pointer();
            _My_data._Mylast  = pointer();
            _My_data._Myend   = pointer();
        }

        _Buy_raw(_Newcapacity);
    }

public:
    void reserve(_CRT_GUARDOVERFLOW const size_type
            _Newcapacity) { // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
        if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)
            if (_Newcapacity > max_size()) {
                _Xlength();
            }

            _Reallocate_exactly(_Newcapacity);
        }
    }

    void shrink_to_fit() { // reduce capacity to size, provide strong guarantee
        if (_Has_unused_capacity()) { // something to do
            if (empty()) {
                _Tidy();
            } else {
                _Reallocate_exactly(size());
            }
        }
    }

    void pop_back() { // erase element at end
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(!empty(), "vector empty before pop");
        _Orphan_range(_Mylast() - 1, _Mylast());
#endif // _ITERATOR_DEBUG_LEVEL == 2

        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast() - 1));
        --_Mylast();
    }

    iterator erase(const_iterator _Where) { // erase element at _Where
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(
            _Where._Getcont() == _STD addressof(_Get_data()) && _Where._Ptr >= _Myfirst() && _Mylast() > _Where._Ptr,
            "vector erase iterator outside range");
        _Orphan_range(_Where._Ptr, _Mylast());
#endif // _ITERATOR_DEBUG_LEVEL == 2

        _Move_unchecked(_Where._Ptr + 1, _Mylast(), _Where._Ptr);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast() - 1));
        --_Mylast();
        return iterator(_Where._Ptr, _STD addressof(_Get_data()));
    }

    iterator erase(const_iterator _First, const_iterator _Last) { // erase [_First, _Last)
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_First._Getcont() == _STD addressof(_Get_data()) && _Last._Getcont() == _STD addressof(_Get_data())
                        && _First._Ptr >= _Myfirst() && _Last._Ptr >= _First._Ptr && _Mylast() >= _Last._Ptr,
            "vector erase iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        if (_First._Ptr != _Last._Ptr) { // something to do, invalidate iterators
            _Orphan_range(_First._Ptr, _Mylast());
        }

        const pointer _Newlast = _Move_unchecked(_Last._Ptr, _Mylast(), _First._Ptr);
        _Destroy(_Newlast, _Mylast());
        _Mylast() = _Newlast;

        return iterator(_First._Ptr, _STD addressof(_Get_data()));
    }

    void clear() noexcept { // erase all
        _Orphan_all();
        _Destroy(_Myfirst(), _Mylast());
        _Mylast() = _Myfirst();
    }

private:
    void _Swap_val(vector& _Right) noexcept {
        _Swap_proxy_and_iterators(_Right);
        _Swap_adl(_Myfirst(), _Right._Myfirst());
        _Swap_adl(_Mylast(), _Right._Mylast());
        _Swap_adl(_Myend(), _Right._Myend());
    }

public:
    void swap(vector& _Right) noexcept { // strengthened
        // exchange contents with _Right
        if (this != _STD addressof(_Right)) { // (maybe) swap allocators, swap control information
            _Pocs(_Getal(), _Right._Getal());
            _Swap_val(_Right);
        }
    }

    _NODISCARD _Ty* data() noexcept { // return address of first element
        return _Unfancy_maybe_null(_Myfirst());
    }

    _NODISCARD const _Ty* data() const noexcept { // return address of first element
        return _Unfancy_maybe_null(_Myfirst());
    }

    _NODISCARD iterator begin() noexcept { // return iterator for beginning of mutable sequence
        return iterator(_Myfirst(), _STD addressof(_Get_data()));
    }

    _NODISCARD const_iterator begin() const noexcept { // return iterator for beginning of nonmutable sequence
        return const_iterator(_Myfirst(), _STD addressof(_Get_data()));
    }

    _NODISCARD iterator end() noexcept { // return iterator for end of mutable sequence
        return iterator(_Mylast(), _STD addressof(_Get_data()));
    }

    _NODISCARD const_iterator end() const noexcept { // return iterator for end of nonmutable sequence
        return const_iterator(_Mylast(), _STD addressof(_Get_data()));
    }

    _NODISCARD reverse_iterator rbegin() noexcept { // return iterator for beginning of reversed mutable sequence
        return reverse_iterator(end());
    }

    _NODISCARD const_reverse_iterator rbegin() const
        noexcept { // return iterator for beginning of reversed nonmutable sequence
        return const_reverse_iterator(end());
    }

    _NODISCARD reverse_iterator rend() noexcept { // return iterator for end of reversed mutable sequence
        return reverse_iterator(begin());
    }

    _NODISCARD const_reverse_iterator rend() const noexcept { // return iterator for end of reversed nonmutable sequence
        return const_reverse_iterator(begin());
    }

    _NODISCARD const_iterator cbegin() const noexcept { // return iterator for beginning of nonmutable sequence
        return begin();
    }

    _NODISCARD const_iterator cend() const noexcept { // return iterator for end of nonmutable sequence
        return end();
    }

    _NODISCARD const_reverse_iterator crbegin() const
        noexcept { // return iterator for beginning of reversed nonmutable sequence
        return rbegin();
    }

    _NODISCARD const_reverse_iterator crend() const
        noexcept { // return iterator for end of reversed nonmutable sequence
        return rend();
    }

    pointer _Unchecked_begin() noexcept { // return pointer for beginning of mutable sequence
        return _Myfirst();
    }

    const_pointer _Unchecked_begin() const noexcept { // return pointer for beginning of nonmutable sequence
        return _Myfirst();
    }

    pointer _Unchecked_end() noexcept { // return pointer for end of mutable sequence
        return _Mylast();
    }

    const_pointer _Unchecked_end() const noexcept { // return pointer for end of nonmutable sequence
        return _Mylast();
    }

    _NODISCARD bool empty() const noexcept { // test if sequence is empty
        return _Myfirst() == _Mylast();
    }

    _NODISCARD size_type size() const noexcept { // return length of sequence
        return static_cast<size_type>(_Mylast() - _Myfirst());
    }

    _NODISCARD size_type max_size() const noexcept { // return maximum possible length of sequence
        return _Min_value(
            static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
    }

    _NODISCARD size_type capacity() const noexcept { // return current length of allocated storage
        return static_cast<size_type>(_Myend() - _Myfirst());
    }

private:
    size_type _Unused_capacity() const noexcept { // micro-optimization for capacity() - size()
        return static_cast<size_type>(_Myend() - _Mylast());
    }

    bool _Has_unused_capacity() const noexcept { // micro-optimization for capacity() != size()
        return _Myend() != _Mylast();
    }

public:
    _NODISCARD _Ty& operator[](const size_type _Pos) { // subscript mutable sequence
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Pos < size(), "vector subscript out of range");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _Myfirst()[_Pos];
    }

    _NODISCARD const _Ty& operator[](const size_type _Pos) const { // subscript nonmutable sequence
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Pos < size(), "vector subscript out of range");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _Myfirst()[_Pos];
    }

    _NODISCARD _Ty& at(const size_type _Pos) { // subscript mutable sequence with checking
        if (size() <= _Pos) {
            _Xrange();
        }

        return _Myfirst()[_Pos];
    }

    _NODISCARD const _Ty& at(const size_type _Pos) const { // subscript nonmutable sequence with checking
        if (size() <= _Pos) {
            _Xrange();
        }

        return _Myfirst()[_Pos];
    }

    _NODISCARD _Ty& front() { // return first element of mutable sequence
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(!empty(), "front() called on empty vector");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return *_Myfirst();
    }

    _NODISCARD const _Ty& front() const { // return first element of nonmutable sequence
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(!empty(), "front() called on empty vector");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return *_Myfirst();
    }

    _NODISCARD _Ty& back() { // return last element of mutable sequence
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(!empty(), "back() called on empty vector");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _Mylast()[-1];
    }

    _NODISCARD const _Ty& back() const { // return last element of nonmutable sequence
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(!empty(), "back() called on empty vector");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _Mylast()[-1];
    }

    _NODISCARD allocator_type get_allocator() const noexcept { // return allocator object for values
        return static_cast<allocator_type>(_Getal());
    }

private:
    // _Udefault is an ABI zombie name

    pointer _Ufill(pointer _Dest, const size_type _Count,
        const _Ty& _Val) { // fill raw _Dest with _Count copies of _Val, using allocator
        return _Uninitialized_fill_n(_Dest, _Count, _Val, _Getal());
    }

    pointer _Ufill(pointer _Dest, const size_type _Count,
        _Value_init_tag) { // fill raw _Dest with _Count value-initialized objects, using allocator
        return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());
    }

    template <class _Iter>
    pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) { // copy [_First, _Last) to raw _Dest, using allocator
        return _Uninitialized_copy(_First, _Last, _Dest, _Getal());
    }

    pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator
        return _Uninitialized_move(_First, _Last, _Dest, _Getal());
    }

    void _Umove_if_noexcept1(
        pointer _First, pointer _Last, pointer _Dest, true_type) { // move [_First, _Last) to raw _Dest, using allocator
        _Uninitialized_move(_First, _Last, _Dest, _Getal());
    }

    void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest,
        false_type) { // copy [_First, _Last) to raw _Dest, using allocator
        _Uninitialized_copy(_First, _Last, _Dest, _Getal());
    }

    void _Umove_if_noexcept(pointer _First, pointer _Last,
        pointer _Dest) { // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
        _Umove_if_noexcept1(_First, _Last, _Dest,
            bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
    }

    void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator
        _Destroy_range(_First, _Last, _Getal());
    }

    size_type _Calculate_growth(
        const size_type _Newsize) const { // given _Oldcapacity and _Newsize, calculate geometric growth
        const size_type _Oldcapacity = capacity();

        if (_Oldcapacity > max_size() - _Oldcapacity / 2) {
            return _Newsize; // geometric growth would overflow
        }

        const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

        if (_Geometric < _Newsize) {
            return _Newsize; // geometric growth would be insufficient
        }

        return _Geometric; // geometric growth is sufficient
    }

    // _Buy is an abi zombie name
    void _Buy_raw(const size_type _Newcapacity) { // allocate array with _Newcapacity elements
                                                  // pre: *this is _Tidy
                                                  // pre: _Newcapacity is in (0, max_size()]
        auto& _My_data    = _Get_data();
        _My_data._Myfirst = _Getal().allocate(_Newcapacity);
        _My_data._Mylast  = _My_data._Myfirst;
        _My_data._Myend   = _My_data._Myfirst + _Newcapacity;
    }

    void _Buy_nonzero(const size_type _Newcapacity) { // allocate array with _Newcapacity elements
                                                      // pre: *this is _Tidy
                                                      // pre: _Newcapacity != 0
        if (_Newcapacity > max_size()) {
            _Xlength();
        }

        _Buy_raw(_Newcapacity);
    }

    void _Change_array(const pointer _Newvec, const size_type _Newsize,
        const size_type _Newcapacity) { // orphan all iterators, discard old array, acquire new array
        _Orphan_all();

        if (_Myfirst() != pointer()) { // destroy and deallocate old array
            _Destroy(_Myfirst(), _Mylast());
            _Getal().deallocate(_Myfirst(), capacity());
        }

        _Myfirst() = _Newvec;
        _Mylast()  = _Newvec + _Newsize;
        _Myend()   = _Newvec + _Newcapacity;
    }

    void _Tidy() noexcept { // free all storage
        _Orphan_all();
        auto& _My_data    = _Get_data();
        const auto _First = _My_data._Myfirst;
        if (_First != pointer()) { // destroy and deallocate old array
            _Destroy(_First, _My_data._Mylast);
            _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

            _My_data._Myfirst = pointer();
            _My_data._Mylast  = pointer();
            _My_data._Myend   = pointer();
        }
    }

    [[noreturn]] static void _Xlength() { // report a length_error
        _Xlength_error("vector<T> too long");
    }

    [[noreturn]] static void _Xrange() { // report an out_of_range error
        _Xout_of_range("invalid vector<T> subscript");
    }

    void _Orphan_range(pointer _First, pointer _Last) const { // orphan iterators within specified (inclusive) range
#if _ITERATOR_DEBUG_LEVEL == 2
        _Lockit _Lock(_LOCK_DEBUG);

        const_iterator** _Pnext = reinterpret_cast<const_iterator**>(_Getpfirst());

        if (_Pnext) {
            while (*_Pnext) {
                if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr) { // skip the iterator
                    _Pnext = reinterpret_cast<const_iterator**>((*_Pnext)->_Getpnext());
                } else { // orphan the iterator
                    (*_Pnext)->_Clrcont();
                    *_Pnext = *reinterpret_cast<const_iterator**>((*_Pnext)->_Getpnext());
                }
            }
        }
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
        (void) _First;
        (void) _Last;
#endif // _ITERATOR_DEBUG_LEVEL == 2
    }

#if _ITERATOR_DEBUG_LEVEL != 0
    _Iterator_base12** _Getpfirst() const { // get address of iterator chain
        return _Get_data()._Getpfirst();
    }

    _Container_proxy*& _Myproxy() noexcept { // return reference to _Myproxy
        return _Get_data()._Myproxy;
    }

    _Container_proxy* const& _Myproxy() const noexcept { // return const reference to _Myproxy
        return _Get_data()._Myproxy;
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0

    void _Orphan_all() noexcept { // orphan all iterators
        _Get_data()._Orphan_all();
    }

    void _Swap_proxy_and_iterators(vector& _Right) { // swap all iterators
        _Get_data()._Swap_proxy_and_iterators(_Right._Get_data());
    }

    _Alty& _Getal() noexcept { // return reference to allocator
        return _Mypair._Get_first();
    }

    const _Alty& _Getal() const noexcept { // return const reference to allocator
        return _Mypair._Get_first();
    }

    _Scary_val& _Get_data() noexcept { // return reference to _Scary_val
        return _Mypair._Get_second();
    }

    const _Scary_val& _Get_data() const noexcept { // return const reference to _Scary_val
        return _Mypair._Get_second();
    }

    iterator _Make_iterator(const pointer _Ptr) noexcept { // return an iterator for pointer _Ptr
        return iterator(_Ptr, _STD addressof(_Mypair._Get_second()));
    }

    iterator _Make_iterator_offset(
        const size_type _Offset) noexcept { // return the iterator begin() + _Offset without a debugging check
        auto& _My_data = _Mypair._Get_second();
        return iterator(_My_data._Myfirst + _Offset, _STD addressof(_My_data));
    }

    pointer& _Myfirst() noexcept { // return reference to _Myfirst
        return _Get_data()._Myfirst;
    }

    const pointer& _Myfirst() const noexcept { // return const reference to _Myfirst
        return _Get_data()._Myfirst;
    }

    pointer& _Mylast() noexcept { // return reference to _Mylast
        return _Get_data()._Mylast;
    }

    const pointer& _Mylast() const noexcept { // return const reference to _Mylast
        return _Get_data()._Mylast;
    }

    pointer& _Myend() noexcept { // return reference to _Myend
        return _Get_data()._Myend;
    }

    const pointer& _Myend() const noexcept { // return const reference to _Myend
        return _Get_data()._Myend;
    }

    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};

#if _HAS_CXX17
template <class _Iter, class _Alloc = allocator<_Iter_value_t<_Iter>>,
    enable_if_t<conjunction_v<_Is_iterator<_Iter>, _Is_allocator<_Alloc>>, int> = 0>
vector(_Iter, _Iter, _Alloc = _Alloc())->vector<_Iter_value_t<_Iter>, _Alloc>;
#endif // _HAS_CXX17

template <class _Ty, class _Alloc>
inline void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right) noexcept { // strengthened
    // swap _Left and _Right vectors
    _Left.swap(_Right);
}

template <class _Ty, class _Alloc>
_NODISCARD inline bool operator==(
    const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) { // test for vector equality
    return _Left.size() == _Right.size() && _STD equal(_Left.begin(), _Left.end(), _Right.begin());
}

template <class _Ty, class _Alloc>
_NODISCARD inline bool operator!=(
    const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) { // test for vector inequality
    return !(_Left == _Right);
}

template <class _Ty, class _Alloc>
_NODISCARD inline bool operator<(
    const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) { // test if _Left < _Right for vectors
    return _STD lexicographical_compare(_Left.begin(), _Left.end(), _Right.begin(), _Right.end());
}

template <class _Ty, class _Alloc>
_NODISCARD inline bool operator>(
    const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) { // test if _Left > _Right for vectors
    return _Right < _Left;
}

template <class _Ty, class _Alloc>
_NODISCARD inline bool operator<=(
    const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) { // test if _Left <= _Right for vectors
    return !(_Right < _Left);
}

template <class _Ty, class _Alloc>
_NODISCARD inline bool operator>=(
    const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) { // test if _Left >= _Right for vectors
    return !(_Left < _Right);
}

// CLASS TEMPLATE vector<bool, Alloc> AND FRIENDS
using _Vbase         = unsigned int; // word type for vector<bool> representation
constexpr int _VBITS = 8 * sizeof(_Vbase); // at least CHAR_BITS bits per word

template <class _Alloc0>
struct _Wrap_alloc { // TRANSITION, ABI compat, preserves symbol names of vector<bool>::iterator
    using _Alloc = _Alloc0;
};

// CLASS _Vb_iter_base
template <class _Alvbase_wrapped>
class _Vb_iter_base : public _Iterator_base { // store information common to reference and iterators
public:
    using _Alvbase = typename _Alvbase_wrapped::_Alloc;
    using _Sizet   = typename allocator_traits<_Alvbase>::size_type;
    using _Difft   = typename allocator_traits<_Alvbase>::difference_type;
    using _Mycont  = vector<bool, _Rebind_alloc_t<_Alvbase, bool>>;

    _Vb_iter_base() : _Myptr(nullptr), _Myoff(0) { // construct with null pointer
    }

    _Vb_iter_base(const _Vbase* _Ptr, _Sizet _Off, const _Container_base* _Mypvbool)
        : _Myptr(_Ptr), _Myoff(_Off) { // construct with offset and pointer
        this->_Adopt(_Mypvbool);
    }

    void _Advance(_Sizet _Off) { // advance iterator by _Off
        _Myoff += _Off;
        _Myptr += _Myoff / _VBITS;
        _Myoff %= _VBITS;
    }

    int _Valid(_Sizet _Inc) const { // test for valid incremented offset
#if _ITERATOR_DEBUG_LEVEL == 2
        const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());
        _Sizet _Mysize   = _Cont->_Mysize;

        _Inc += _Myoff;
        _Inc += static_cast<_Sizet>(_VBITS * (_Myptr - _Cont->_Myvec.data()));
        return _Inc < _Mysize ? -1 : _Inc == _Mysize ? 0 : +1;

#else // _ITERATOR_DEBUG_LEVEL == 2
        (void) _Inc;
        return -1;
#endif // _ITERATOR_DEBUG_LEVEL == 2
    }

    const _Vbase* _Myptr;
    _Sizet _Myoff;
};

// CLASS _Vb_reference
template <class _Alvbase_wrapped>
class _Vb_reference : public _Vb_iter_base<_Alvbase_wrapped> { // reference to a bit within a base word
    using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;

    _Vb_reference() noexcept { // construct with null pointer (private)
    }

public:
    _Vb_reference(const _Mybase& _Right)
        : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont()) { // construct with base
    }

    _Vb_reference& operator=(const _Vb_reference& _Right) noexcept { // assign _Vb_reference _Right to bit

        return *this = bool(_Right);
    }

    _Vb_reference& operator=(bool _Val) noexcept { // assign _Val to bit
        if (_Val) {
            *const_cast<_Vbase*>(_Getptr()) |= _Mask();
        } else {
            *const_cast<_Vbase*>(_Getptr()) &= ~_Mask();
        }

        return *this;
    }

    void flip() noexcept { // toggle the bit
        *const_cast<_Vbase*>(_Getptr()) ^= _Mask();
    }

    operator bool() const noexcept { // test if bit is set
        return (*_Getptr() & _Mask()) != 0;
    }

    const _Vbase* _Getptr() const { // get pointer to base word
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(
            this->_Getcont() && this->_Myptr && this->_Valid(0) < 0, "vector<bool> iterator not dereferencable");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return this->_Myptr;
    }

protected:
    _Vbase _Mask() const { // convert offset to mask
        return static_cast<_Vbase>(1) << this->_Myoff;
    }
};

template <class _Alvbase_wrapped>
inline void swap(_Vb_reference<_Alvbase_wrapped> _Left,
    _Vb_reference<_Alvbase_wrapped> _Right) noexcept { // swap _Left and _Right vector<bool> elements
    bool _Val = _Left; // NOT _STD swap
    _Left     = _Right;
    _Right    = _Val;
}

// CLASS _Vb_const_iterator
template <class _Alvbase_wrapped>
class _Vb_const_iterator : public _Vb_iter_base<_Alvbase_wrapped> { // iterator for nonmutable vector<bool>
private:
    using _Mybase    = _Vb_iter_base<_Alvbase_wrapped>;
    using _Size_type = typename _Mybase::_Sizet;

public:
    using _Reft           = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::_Difft;
    using pointer           = const_reference*;
    using reference         = const_reference;

    _Vb_const_iterator() { // construct with null reference
    }

    _Vb_const_iterator(const _Vbase* _Ptr, const _Container_base* _Mypvbool)
        : _Mybase(_Ptr, 0, _Mypvbool) { // construct with offset and pointer
    }

    _NODISCARD const_reference operator*() const { // return (reference to) designated object
        return _Reft(*this);
    }

    _Vb_const_iterator& operator++() { // preincrement
        _Inc();
        return *this;
    }

    _Vb_const_iterator operator++(int) { // postincrement
        _Vb_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    _Vb_const_iterator& operator--() { // predecrement
        _Dec();
        return *this;
    }

    _Vb_const_iterator operator--(int) { // postdecrement
        _Vb_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    _Vb_const_iterator& operator+=(const difference_type _Off) { // increment by integer
        if (_Off < 0 && this->_Myoff < 0 - static_cast<_Size_type>(_Off)) { // add negative increment
            this->_Myoff += _Off;
            this->_Myptr -= 1 + (static_cast<_Size_type>(-1) - this->_Myoff) / _VBITS;
            this->_Myoff %= _VBITS;
        } else { // add non-negative increment
            this->_Myoff += _Off;
            this->_Myptr += this->_Myoff / _VBITS;
            this->_Myoff %= _VBITS;
        }
        return *this;
    }

    _NODISCARD _Vb_const_iterator operator+(const difference_type _Off) const { // return this + integer
        _Vb_const_iterator _Tmp = *this;
        return _Tmp += _Off;
    }

    _Vb_const_iterator& operator-=(const difference_type _Off) { // decrement by integer
        return *this += -_Off;
    }

    _NODISCARD _Vb_const_iterator operator-(const difference_type _Off) const { // return this - integer
        _Vb_const_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }

    _NODISCARD difference_type operator-(const _Vb_const_iterator& _Right) const { // return difference of iterators
        _Compat(_Right);
        return static_cast<difference_type>(_VBITS * (this->_Myptr - _Right._Myptr))
               + static_cast<difference_type>(this->_Myoff) - static_cast<difference_type>(_Right._Myoff);
    }

    _NODISCARD const_reference operator[](const difference_type _Off) const { // subscript
        return *(*this + _Off);
    }

    _NODISCARD bool operator==(const _Vb_const_iterator& _Right) const { // test for iterator equality
        _Compat(_Right);
        return this->_Myptr == _Right._Myptr && this->_Myoff == _Right._Myoff;
    }

    _NODISCARD bool operator!=(const _Vb_const_iterator& _Right) const { // test for iterator inequality
        return !(*this == _Right);
    }

    _NODISCARD bool operator<(const _Vb_const_iterator& _Right) const { // test if this < _Right
        _Compat(_Right);
        return this->_Myptr < _Right._Myptr || (this->_Myptr == _Right._Myptr && this->_Myoff < _Right._Myoff);
    }

    _NODISCARD bool operator>(const _Vb_const_iterator& _Right) const { // test if this > _Right
        return _Right < *this;
    }

    _NODISCARD bool operator<=(const _Vb_const_iterator& _Right) const { // test if this <= _Right
        return !(_Right < *this);
    }

    _NODISCARD bool operator>=(const _Vb_const_iterator& _Right) const { // test if this >= _Right
        return !(*this < _Right);
    }

    void _Compat(const _Vb_const_iterator& _Right) const { // test for compatible iterator pair
#if _ITERATOR_DEBUG_LEVEL == 0
        (void) _Right;
#else // _ITERATOR_DEBUG_LEVEL == 0
        _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector<bool> iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL
    }

#if _ITERATOR_DEBUG_LEVEL != 0
    using _Prevent_inheriting_unwrap = _Vb_const_iterator;

    friend void _Verify_range(const _Vb_const_iterator& _First, const _Vb_const_iterator& _Last) {
        // note _Compat check inside <=
        _STL_VERIFY(_First <= _Last, "vector<bool> iterator range transposed");
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0

    void _Dec() { // decrement bit position
        if (this->_Myoff != 0) {
            --this->_Myoff;
        } else { // move to previous word
#if _ITERATOR_DEBUG_LEVEL != 0
            _STL_VERIFY(this->_Getcont(), "cannot decrement value-initialized vector<bool> iterator");
            _STL_VERIFY(
                this->_Valid(static_cast<_Size_type>(-1)) <= 0, "cannot decrement invalid vector<bool> iterator");
#endif // _ITERATOR_DEBUG_LEVEL

            this->_Myoff = _VBITS - 1;
            --this->_Myptr;
        }
    }

    void _Inc() { // increment bit position
        if (this->_Myoff < _VBITS - 1) {
            ++this->_Myoff;
        } else { // move to next word
#if _ITERATOR_DEBUG_LEVEL != 0
            _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized vector<bool> iterator");
            _STL_VERIFY(this->_Valid(1) <= 0, "cannot increment invalid vector<bool> iterator");
#endif // _ITERATOR_DEBUG_LEVEL

            this->_Myoff = 0;
            ++this->_Myptr;
        }
    }
};

template <class _Alvbase_wrapped>
_NODISCARD _Vb_const_iterator<_Alvbase_wrapped> operator+(
    typename _Vb_const_iterator<_Alvbase_wrapped>::difference_type _Off,
    _Vb_const_iterator<_Alvbase_wrapped> _Right) { // return _Right + integer
    return _Right += _Off;
}

// CLASS _Vb_iterator
template <class _Alvbase_wrapped>
class _Vb_iterator : public _Vb_const_iterator<_Alvbase_wrapped> { // iterator for mutable vector<bool>
public:
    using _Mybase = _Vb_const_iterator<_Alvbase_wrapped>;

    using _Reft           = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::difference_type;
    using pointer           = _Reft*;
    using reference         = _Reft;

    _Vb_iterator() { // construct with null reference
    }

    _Vb_iterator(_Vbase* _Ptr, _Container_base* _Mypvbool)
        : _Mybase(_Ptr, _Mypvbool) { // construct with offset and pointer
    }

    _NODISCARD reference operator*() const { // return (reference to) designated object
        return _Reft(*this);
    }

    _Vb_iterator& operator++() { // preincrement
        ++*(_Mybase*) this;
        return *this;
    }

    _Vb_iterator operator++(int) { // postincrement
        _Vb_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    _Vb_iterator& operator--() { // predecrement
        --*(_Mybase*) this;
        return *this;
    }

    _Vb_iterator operator--(int) { // postdecrement
        _Vb_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    _Vb_iterator& operator+=(const difference_type _Off) { // increment by integer
        *(_Mybase*) this += _Off;
        return *this;
    }

    _NODISCARD _Vb_iterator operator+(const difference_type _Off) const { // return this + integer
        _Vb_iterator _Tmp = *this;
        return _Tmp += _Off;
    }

    _Vb_iterator& operator-=(const difference_type _Off) { // decrement by integer
        return *this += -_Off;
    }

    _NODISCARD _Vb_iterator operator-(const difference_type _Off) const { // return this - integer
        _Vb_iterator _Tmp = *this;
        return _Tmp -= _Off;
    }

    _NODISCARD difference_type operator-(const _Mybase& _Right) const { // return difference of iterators
        return *(_Mybase*) this - _Right;
    }

    _NODISCARD reference operator[](const difference_type _Off) const { // subscript
        return *(*this + _Off);
    }

    using _Prevent_inheriting_unwrap = _Vb_iterator;
};

template <class _Alvbase_wrapped>
_NODISCARD inline _Vb_iterator<_Alvbase_wrapped> operator+(
    typename _Vb_iterator<_Alvbase_wrapped>::difference_type _Off,
    _Vb_iterator<_Alvbase_wrapped> _Right) { // return _Right + integer
    return _Right += _Off;
}

// CLASS TEMPLATE _Vb_val
template <class _Alloc>
class _Vb_val : public _Container_base { // base class for vector<bool> to hold data
public:
    using _Alvbase         = _Rebind_alloc_t<_Alloc, _Vbase>;
    using _Alvbase_traits  = allocator_traits<_Alvbase>;
    using _Vectype         = vector<_Vbase, _Alvbase>;
    using _Alvbase_wrapped = _Wrap_alloc<_Alvbase>;
    using size_type        = typename _Alvbase_traits::size_type;

    _Vb_val() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Vectype>)
        : _Myvec(), _Mysize(0) { // construct empty vector
        this->_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _Vb_val(const _Alloc& _Al) _NOEXCEPT_COND(is_nothrow_constructible_v<_Vectype, _Alvbase>)
        : _Myvec(static_cast<_Alvbase>(_Al)), _Mysize(0) { // construct empty vector, allocator
        this->_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _Vb_val(size_type _Count, const bool& _Val)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0)), _Mysize(0) { // construct _Count * _Val elements
        this->_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0), static_cast<_Alvbase>(_Al)),
          _Mysize(0) { // construct _Count * _Val elements with allocator _Al
        this->_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _Vb_val(const _Vb_val& _Right) : _Myvec(_Right._Myvec), _Mysize(_Right._Mysize) { // copy construct
        this->_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
        : _Myvec(_Right._Myvec, static_cast<_Alvbase>(_Al)), _Mysize(_Right._Mysize) { // copy construct, allocator
        this->_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _Vb_val(_Vb_val&& _Right) _NOEXCEPT_COND(is_nothrow_move_constructible_v<_Vectype>)
        : _Myvec(_STD move(_Right._Myvec)), _Mysize(_STD exchange(_Right._Mysize, size_type{0})) { // move construct
        this->_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _Vb_val(_Vb_val&& _Right, const _Alloc& _Al)
        _NOEXCEPT_COND(is_nothrow_constructible_v<_Vectype, _Vectype, _Alvbase>)
        : _Myvec(_STD move(_Right._Myvec), static_cast<_Alvbase>(_Al)),
          _Mysize(_STD exchange(_Right._Mysize, size_type{0})) { // move construct, allocator
        this->_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    ~_Vb_val() noexcept { // destroy proxy
#if _ITERATOR_DEBUG_LEVEL != 0
        this->_Orphan_all();
        auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alvbase, this->_Getal());
        _Delete_plain(_Alproxy, _STD exchange(this->_Myproxy, nullptr));
#endif /* _ITERATOR_DEBUG_LEVEL != 0 */
    }

    _Alvbase& _Getal() noexcept {
        return _Myvec._Getal();
    }

    const _Alvbase& _Getal() const noexcept {
        return _Myvec._Getal();
    }

    static size_type _Nw(size_type _Count) { // return number of base words from number of bits
        return (_Count + _VBITS - 1) / _VBITS;
    }

    _Vectype _Myvec; // base vector of words
    size_type _Mysize; // current length of sequence
};

// CLASS vector<bool>
template <class _Alloc>
class vector<bool, _Alloc> : public _Vb_val<_Alloc> { // varying size array of bits
public:
    static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<bool, typename _Alloc::value_type>,
        _MISMATCHED_ALLOCATOR_MESSAGE("vector<bool, Allocator>", "bool"));

    using _Mybase          = _Vb_val<_Alloc>;
    using _Alvbase_wrapped = typename _Mybase::_Alvbase_wrapped;
    using _Alvbase         = typename _Mybase::_Alvbase;
    using _Alvbase_traits  = typename _Mybase::_Alvbase_traits;

    using size_type       = typename _Alvbase_traits::size_type;
    using difference_type = typename _Alvbase_traits::difference_type;
    using allocator_type  = _Alloc;

    using reference       = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;
    using value_type      = bool;

    using _Reft          = reference;
    using iterator       = _Vb_iterator<_Alvbase_wrapped>;
    using const_iterator = _Vb_const_iterator<_Alvbase_wrapped>;

    using pointer                = iterator;
    using const_pointer          = const_iterator;
    using reverse_iterator       = _STD reverse_iterator<iterator>;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

    static const int _VBITS = _STD _VBITS;
    enum { _EEN_VBITS = _VBITS }; // helper for expression evaluator

    vector() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Mybase>) // strengthened
        : _Mybase() { // construct empty vector
    }

    explicit vector(const _Alloc& _Al)
        _NOEXCEPT_COND(is_nothrow_constructible_v<_Mybase, const _Alloc&>) // strengthened
        : _Mybase(_Al) { // construct empty vector, allocator
    }

    explicit vector(_CRT_GUARDOVERFLOW size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mybase(_Count, false, _Al) { // construct from _Count * false, optional allocator
        _Trim(_Count);
    }

    vector(_CRT_GUARDOVERFLOW size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
        : _Mybase(_Count, _Val, _Al) { // construct from _Count * _Val, optional allocator
        _Trim(_Count);
    }

    vector(const vector& _Right) : _Mybase(_Right) { // construct by copying _Right
    }

    vector(const vector& _Right, const _Alloc& _Al) : _Mybase(_Right, _Al) { // construct by copying _Right, allocator
    }

    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mybase(_Al) { // construct from [_First, _Last), optional allocator
        _BConstruct(_First, _Last);
    }

    template <class _Iter>
    void _BConstruct(_Iter _First, _Iter _Last) { // initialize from [_First, _Last), input iterators
        insert(begin(), _First, _Last);
    }

    vector(vector&& _Right) _NOEXCEPT_COND(is_nothrow_move_constructible_v<_Mybase>) // strengthened
        : _Mybase(_STD move(_Right)) { // move construct by moving _Right
        this->_Swap_proxy_and_iterators(_Right);
    }

    vector(vector&& _Right, const _Alloc& _Al)
        _NOEXCEPT_COND(is_nothrow_constructible_v<_Mybase, _Mybase, const _Alloc&>)
        : _Mybase(_STD move(_Right), _Al) { // move construct by moving _Right, allocator
        if
            _CONSTEXPR_IF(!_Alvbase_traits::is_always_equal::value) {
                if (this->_Getal() != _Right._Getal()) {
                    return;
                }
            }

        this->_Swap_proxy_and_iterators(_Right);
    }

private:
#if _ITERATOR_DEBUG_LEVEL != 0
    void _Move_assign(vector& _Right, _Equal_allocators) noexcept {
        this->_Myvec  = _STD move(_Right._Myvec);
        this->_Mysize = _STD exchange(_Right._Mysize, size_type{0});
        this->_Swap_proxy_and_iterators(_Right);
    }

    void _Move_assign(vector& _Right, _Propagate_allocators) noexcept {
        using _Alproxy_type = _Rebind_alloc_t<_Alvbase, _Container_proxy>;
        if (this->_Getal() != _Right._Getal()) { // reload proxy
            // intentionally slams into noexcept on OOM, TRANSITION, VSO#466800
            _Alproxy_type _Oldal(this->_Getal());
            _Alproxy_type _Right_proxy_al(_Right._Getal());
            _Container_proxy_ptr<_Alvbase> _Proxy(_Right_proxy_al, _Leave_proxy_unbound{});
            this->_Myvec  = _STD move(_Right._Myvec);
            this->_Mysize = _STD exchange(_Right._Mysize, size_type{0});
            _Proxy._Bind(_Oldal, this);
            this->_Swap_proxy_and_iterators(_Right);
            return;
        }

        this->_Myvec  = _STD move(_Right._Myvec);
        this->_Mysize = _STD exchange(_Right._Mysize, size_type{0});
        this->_Swap_proxy_and_iterators(_Right);
    }

    void _Move_assign(vector& _Right, _No_propagate_allocators) {
        this->_Myvec  = _STD move(_Right._Myvec);
        this->_Mysize = _STD exchange(_Right._Mysize, size_type{0});
        if (this->_Getal() == _Right._Getal()) {
            this->_Swap_proxy_and_iterators(_Right);
        }
    }
#endif /* _ITERATOR_DEBUG_LEVEL != 0 */

public:
    vector& operator=(vector&& _Right) _NOEXCEPT_COND(is_nothrow_move_assignable_v<_Mybase>) {
        if (this != _STD addressof(_Right)) { // different, assign it
#if _ITERATOR_DEBUG_LEVEL == 0
            this->_Myvec  = _STD move(_Right._Myvec);
            this->_Mysize = _STD exchange(_Right._Mysize, size_type{0});
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
            this->_Orphan_all();
            _Move_assign(_Right, _Choose_pocma<_Alvbase>{});
#endif // _ITERATOR_DEBUG_LEVEL == 0
        }
        return *this;
    }

    template <class... _Valty>
    decltype(auto) emplace_back(_Valty&&... _Val) { // insert bool at end
        bool _Tmp(_STD forward<_Valty>(_Val)...);
        push_back(_Tmp);

#if _HAS_CXX17
        return back();
#endif // _HAS_CXX17
    }

    template <class... _Valty>
    iterator emplace(const_iterator _Where, _Valty&&... _Val) { // insert bool at _Where
        bool _Tmp(_STD forward<_Valty>(_Val)...);
        return insert(_Where, _Tmp);
    }

    vector(initializer_list<bool> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mybase(0, false, _Al) { // construct from initializer_list
        insert(begin(), _Ilist.begin(), _Ilist.end());
    }

    vector& operator=(initializer_list<bool> _Ilist) { // assign initializer_list
        assign(_Ilist.begin(), _Ilist.end());
        return *this;
    }

    void assign(initializer_list<bool> _Ilist) { // assign initializer_list
        assign(_Ilist.begin(), _Ilist.end());
    }

    iterator insert(const_iterator _Where,
        initializer_list<bool> _Ilist) { // insert initializer_list
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }

    ~vector() noexcept { // destroy the object
    }

private:
#if _ITERATOR_DEBUG_LEVEL != 0
    void _Copy_assign(const vector& _Right, false_type) {
        this->_Myvec  = _Right._Myvec;
        this->_Mysize = _Right._Mysize;
    }

    void _Copy_assign(const vector& _Right, true_type) {
        if (this->_Getal() == _Right._Getal()) {
            _Copy_assign(_Right, false_type{});
        } else {
            // reload proxy
            using _Alproxy_type = _Rebind_alloc_t<_Alvbase, _Container_proxy>;
            _Alproxy_type _Oldal(this->_Getal());
            _Alproxy_type _Right_proxy_al(_Right._Getal());
            _Container_proxy_ptr<_Alvbase> _Proxy(_Right_proxy_al, _Leave_proxy_unbound{});
            this->_Myvec  = _Right._Myvec;
            this->_Mysize = _Right._Mysize;
            _Proxy._Bind(_Oldal, this);
        }
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0

public:
    vector& operator=(const vector& _Right) { // assign from _Right
        if (this != _STD addressof(_Right)) { // different, assign it
#if _ITERATOR_DEBUG_LEVEL == 0
            this->_Myvec  = _Right._Myvec;
            this->_Mysize = _Right._Mysize;
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
            this->_Orphan_all();
            _Copy_assign(_Right, _Choose_pocca<_Alvbase>{});
#endif // _ITERATOR_DEBUG_LEVEL == 0
        }

        return *this;
    }

    void reserve(_CRT_GUARDOVERFLOW size_type _Count) { // determine new minimum length of allocated storage
        this->_Myvec.reserve(this->_Nw(_Count));
    }

    _NODISCARD size_type capacity() const noexcept { // return current length of allocated storage
        return this->_Myvec.capacity() * _VBITS;
    }

    _NODISCARD iterator begin() noexcept { // return iterator for beginning of mutable sequence
        return iterator(this->_Myvec.data(), this);
    }

    _NODISCARD const_iterator begin() const noexcept { // return iterator for beginning of nonmutable sequence
        return const_iterator(this->_Myvec.data(), this);
    }

    _NODISCARD iterator end() noexcept { // return iterator for end of mutable sequence
        return begin() + static_cast<difference_type>(this->_Mysize);
    }

    _NODISCARD const_iterator end() const noexcept { // return iterator for end of nonmutable sequence
        return begin() + static_cast<difference_type>(this->_Mysize);
    }

    _NODISCARD const_iterator cbegin() const noexcept { // return iterator for beginning of nonmutable sequence
        return begin();
    }

    _NODISCARD const_iterator cend() const noexcept { // return iterator for end of nonmutable sequence
        return end();
    }

    _NODISCARD const_reverse_iterator crbegin() const
        noexcept { // return iterator for beginning of reversed nonmutable sequence
        return rbegin();
    }

    _NODISCARD const_reverse_iterator crend() const
        noexcept { // return iterator for end of reversed nonmutable sequence
        return rend();
    }

    void shrink_to_fit() { // reduce capacity
        if (this->_Myvec.capacity() != this->_Myvec.size()) { // worth shrinking, do it
            this->_Orphan_all();
            this->_Myvec.shrink_to_fit();
        }
    }

    iterator _Make_iter(const_iterator _Where) { // make iterator from const_iterator
        iterator _Tmp = begin();
        if (0 < this->_Mysize) {
            _Tmp += _Where - begin();
        }

        return _Tmp;
    }

    _NODISCARD reverse_iterator rbegin() noexcept { // return iterator for beginning of reversed mutable sequence
        return reverse_iterator(end());
    }

    _NODISCARD const_reverse_iterator rbegin() const
        noexcept { // return iterator for beginning of reversed nonmutable sequence
        return const_reverse_iterator(end());
    }

    _NODISCARD reverse_iterator rend() noexcept { // return iterator for end of reversed mutable sequence
        return reverse_iterator(begin());
    }

    _NODISCARD const_reverse_iterator rend() const noexcept { // return iterator for end of reversed nonmutable sequence
        return const_reverse_iterator(begin());
    }

    void resize(_CRT_GUARDOVERFLOW size_type _Newsize,
        bool _Val = false) { // determine new length, padding with _Val elements as needed
        if (size() < _Newsize) {
            _Insert_n(end(), _Newsize - size(), _Val);
        } else if (_Newsize < size()) {
            erase(begin() + static_cast<difference_type>(_Newsize), end());
        }
    }

    _NODISCARD size_type size() const noexcept { // return length of sequence
        return this->_Mysize;
    }

    _NODISCARD size_type max_size() const noexcept { // return maximum possible length of sequence
        constexpr size_type _Diff_max = static_cast<size_type>((numeric_limits<difference_type>::max)());
        const size_type _Ints_max     = this->_Myvec.max_size();
        if (_Ints_max > _Diff_max / _VBITS) { // max_size bound by difference_type limits
            return _Diff_max;
        }

        // max_size bound by underlying storage limits
        return _Ints_max * _VBITS;
    }

    _NODISCARD bool empty() const noexcept { // test if sequence is empty
        return size() == 0;
    }

    _NODISCARD allocator_type get_allocator() const noexcept { // return allocator object for values
        return static_cast<allocator_type>(this->_Myvec.get_allocator());
    }

    _NODISCARD const_reference at(size_type _Off) const { // subscript nonmutable sequence with checking
        if (size() <= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    _NODISCARD reference at(size_type _Off) { // subscript mutable sequence with checking
        if (size() <= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    _NODISCARD const_reference operator[](size_type _Off) const { // subscript nonmutable sequence
        const_iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    _NODISCARD reference operator[](size_type _Off) { // subscript mutable sequence
        iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    _NODISCARD reference front() { // return first element of mutable sequence
        return *begin();
    }

    _NODISCARD const_reference front() const { // return first element of nonmutable sequence
        return *begin();
    }

    _NODISCARD reference back() { // return last element of mutable sequence
        return *(end() - 1);
    }

    _NODISCARD const_reference back() const { // return last element of nonmutable sequence
        return *(end() - 1);
    }

    void push_back(const bool& _Val) { // insert element at end
        insert(end(), _Val);
    }

    void pop_back() { // erase element at end
        erase(end() - 1);
    }

    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    void assign(_Iter _First, _Iter _Last) { // assign [_First, _Last), input iterators
        clear();
        insert(begin(), _First, _Last);
    }

    void assign(_CRT_GUARDOVERFLOW size_type _Count, const bool& _Val) { // assign _Count * _Val
        clear();
        _Insert_n(begin(), _Count, _Val);
    }

    iterator insert(const_iterator _Where, const bool& _Val) { // insert _Val at _Where
        return _Insert_n(_Where, static_cast<size_type>(1), _Val);
    }

    iterator insert(const_iterator _Where, _CRT_GUARDOVERFLOW size_type _Count,
        const bool& _Val) { // insert _Count * _Val at _Where
        return _Insert_n(_Where, _Count, _Val);
    }

    template <class _Iter, class = enable_if_t<_Is_iterator_v<_Iter>>>
    iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) { // insert [_First, _Last) at _Where
        difference_type _Off = _Where - begin();
        _Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>());
        return begin() + _Off;
    }

    template <class _Iter>
    void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
        input_iterator_tag) { // insert [_First, _Last) at _Where, input iterators
        difference_type _Off = _Where - begin();

        for (; _First != _Last; ++_First, (void) ++_Off) {
            insert(begin() + _Off, *_First);
        }
    }

    template <class _Iter>
    void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
        forward_iterator_tag) { // insert [_First, _Last) at _Where, forward iterators
        _Adl_verify_range(_First, _Last);
        size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
        size_type _Off   = _Insert_x(_Where, _Count);
        _Copy_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), begin() + static_cast<difference_type>(_Off));
    }

    iterator erase(const_iterator _Where_arg) { // erase element at _Where
        iterator _Where      = _Make_iter(_Where_arg);
        difference_type _Off = _Where - begin();

#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(end() > _Where, "vector<bool> erase iterator outside range");
        _STD copy(_Where + 1, end(), _Where);
        _Orphan_range(static_cast<size_type>(_Off), this->_Mysize);

#else // _ITERATOR_DEBUG_LEVEL == 2
        _STD copy(_Where + 1, end(), _Where);
#endif // _ITERATOR_DEBUG_LEVEL == 2

        _Trim(this->_Mysize - 1);
        return begin() + _Off;
    }

    iterator erase(const_iterator _First_arg,
        const_iterator _Last_arg) { // erase [_First, _Last)
        iterator _First      = _Make_iter(_First_arg);
        iterator _Last       = _Make_iter(_Last_arg);
        difference_type _Off = _First - begin();

        if (_First != _Last) { // worth doing, copy down over hole
#if _ITERATOR_DEBUG_LEVEL == 2
            _STL_VERIFY(_Last >= _First && end() >= _Last, "vector<bool> erase iterator outside range");
            iterator _Next      = _STD copy(_Last, end(), _First);
            const auto _Newsize = static_cast<size_type>(_Next - begin());
            _Orphan_range(_Newsize, this->_Mysize);
            _Trim(_Newsize);

#else // _ITERATOR_DEBUG_LEVEL == 2
            iterator _Next = _STD copy(_Last, end(), _First);
            _Trim(static_cast<size_type>(_Next - begin()));
#endif // _ITERATOR_DEBUG_LEVEL == 2
        }
        return begin() + _Off;
    }

    void clear() noexcept { // erase all elements
        this->_Orphan_all();
        this->_Myvec.clear();
        this->_Mysize = 0;
    }

    void flip() noexcept { // toggle all elements
        for (auto& _Elem : this->_Myvec) {
            _Elem = ~_Elem;
        }

        _Trim(this->_Mysize);
    }

    void swap(vector& _Right) noexcept { // strengthened
        // exchange contents with _Right
        if (this != _STD addressof(_Right)) { // (maybe) swap allocators, swap control information
            this->_Swap_proxy_and_iterators(_Right);
            this->_Myvec.swap(_Right._Myvec);
            _STD swap(this->_Mysize, _Right._Mysize);
        }
    }

    static void swap(reference _Left, reference _Right) noexcept { // swap _Left and _Right vector<bool> elements
        bool _Val = _Left; // NOT _STD swap
        _Left     = _Right;
        _Right    = _Val;
    }

    friend hash<vector<bool, _Alloc>>;

    iterator _Insert_n(const_iterator _Where, size_type _Count, const bool& _Val) { // insert _Count * _Val at _Where
        size_type _Off     = _Insert_x(_Where, _Count);
        const auto _Result = begin() + static_cast<difference_type>(_Off);
        _STD fill(_Result, _Result + static_cast<difference_type>(_Count), _Val);
        return _Result;
    }

    size_type _Insert_x(const_iterator _Where, size_type _Count) { // make room to insert _Count elements at _Where
        difference_type _Off = _Where - begin();

#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(end() >= _Where, "vector<bool> insert iterator outside range");
        bool _Realloc = capacity() - size() < _Count;
#endif // _ITERATOR_DEBUG_LEVEL == 2

        if (_Count != 0) {
            if (max_size() - size() < _Count) {
                _Xlen(); // result too long
            }

            // worth doing
            this->_Myvec.resize(this->_Nw(size() + _Count), 0);
            if (empty()) {
                this->_Mysize += _Count;
            } else { // make room and copy down suffix
                iterator _Oldend = end();
                this->_Mysize += _Count;
                _STD copy_backward(begin() + _Off, _Oldend, end());
            }

#if _ITERATOR_DEBUG_LEVEL == 2
            _Orphan_range(static_cast<size_type>(_Realloc ? 0 : _Off), this->_Mysize);
#endif // _ITERATOR_DEBUG_LEVEL == 2
        }

        return static_cast<size_type>(_Off);
    }

#if _ITERATOR_DEBUG_LEVEL == 2
    void _Orphan_range(
        size_type _Offlo, size_type _Offhi) const { // orphan iterators within specified (inclusive) range
        _Lockit _Lock(_LOCK_DEBUG);
        auto _Base = const_cast<_Vbase*>(this->_Myvec.data());

        const_iterator** _Pnext = (const_iterator**) this->_Getpfirst();
        if (_Pnext != nullptr) {
            while (*_Pnext != nullptr) { // test offset from beginning of vector
                size_type _Off = static_cast<size_type>(_VBITS * ((*_Pnext)->_Myptr - _Base)) + (*_Pnext)->_Myoff;
                if (_Off < _Offlo || _Offhi < _Off) {
                    _Pnext = (const_iterator**) (*_Pnext)->_Getpnext();
                } else { // orphan the iterator
                    (*_Pnext)->_Clrcont();
                    *_Pnext = *(const_iterator**) (*_Pnext)->_Getpnext();
                }
            }
        }
    }

#else // _ITERATOR_DEBUG_LEVEL == 2
    void _Orphan_range(size_type, size_type) const { // orphan iterators within specified (inclusive) range
    }
#endif // _ITERATOR_DEBUG_LEVEL == 2

    void _Trim(size_type _Size) { // trim base vector to exact length in bits
        if (max_size() < _Size) {
            _Xlen(); // result too long
        }

        const size_type _Words = this->_Nw(_Size);
        if (_Words < this->_Myvec.size()) {
            this->_Myvec.erase(this->_Myvec.begin() + static_cast<difference_type>(_Words), this->_Myvec.end());
        }

        this->_Mysize = _Size;
        _Size %= _VBITS;
        if (0 < _Size) {
            this->_Myvec[_Words - 1] &= (static_cast<_Vbase>(1) << _Size) - 1;
        }
    }

    [[noreturn]] void _Xlen() const { // report a length_error
        _Xlength_error("vector<bool> too long");
    }

    [[noreturn]] void _Xran() const { // report an out_of_range error
        _Xout_of_range("invalid vector<bool> subscript");
    }
};

template <class _Alloc>
_NODISCARD inline bool operator==(
    const vector<bool, _Alloc>& _Left, const vector<bool, _Alloc>& _Right) { // test for vector equality
    return _Left.size() == _Right.size() && _Left._Myvec == _Right._Myvec;
}

template <class _Alloc>
_NODISCARD inline bool operator!=(
    const vector<bool, _Alloc>& _Left, const vector<bool, _Alloc>& _Right) { // test for vector inequality
    return !(_Left == _Right);
}

// STRUCT TEMPLATE SPECIALIZATION hash
template <class _Alloc>
struct hash<vector<bool, _Alloc>> { // hash functor
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef vector<bool, _Alloc> argument_type;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;

    _NODISCARD size_t operator()(const vector<bool, _Alloc>& _Keyval) const
        noexcept { // hash _Keyval to size_t value by pseudorandomizing transform
        return _Hash_array_representation(_Keyval._Myvec.data(), _Keyval._Myvec.size());
    }
};

#if _HAS_CXX17
namespace pmr {
    template <class _Ty>
    using vector = _STD vector<_Ty, polymorphic_allocator<_Ty>>;
} // namespace pmr
#endif // _HAS_CXX17
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // RC_INVOKED
#endif // _VECTOR_

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
