// xtr1common internal header (core)
#pragma once
#ifndef _XTR1COMMON_
#define _XTR1COMMON_
#ifndef RC_INVOKED
#include <yvals_core.h>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
// STRUCT TEMPLATE integral_constant
template <class _Ty,
    _Ty _Val>
struct integral_constant { // convenient template for integral constant types
    static constexpr _Ty value = _Val;

    using value_type = _Ty;
    using type       = integral_constant;

    constexpr operator value_type() const noexcept { // return stored value
        return value;
    }

    _NODISCARD constexpr value_type operator()() const noexcept { // return stored value
        return value;
    }
};

// ALIAS TEMPLATE bool_constant
template <bool _Val>
using bool_constant = integral_constant<bool, _Val>;

using true_type  = bool_constant<true>;
using false_type = bool_constant<false>;

// STRUCT TEMPLATE enable_if
template <bool _Test,
    class _Ty = void>
struct enable_if { // type is undefined for assumed !_Test
};

template <class _Ty>
struct enable_if<true, _Ty> { // type is _Ty for _Test
    using type = _Ty;
};

template <bool _Test, class _Ty = void>
using enable_if_t = typename enable_if<_Test, _Ty>::type;

// STRUCT TEMPLATE conditional
template <bool _Test, class _Ty1,
    class _Ty2>
struct conditional { // type is _Ty2 for assumed !_Test
    using type = _Ty2;
};

template <class _Ty1, class _Ty2>
struct conditional<true, _Ty1, _Ty2> { // type is _Ty1 for _Test
    using type = _Ty1;
};

template <bool _Test, class _Ty1, class _Ty2>
using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

// STRUCT TEMPLATE is_same
template <class _Ty1,
    class _Ty2>
struct is_same : false_type { // determine whether _Ty1 and _Ty2 are the same type
};

template <class _Ty1>
struct is_same<_Ty1, _Ty1> : true_type { // determine whether _Ty1 and _Ty2 are the same type
};

template <class _Ty, class _Uty>
_INLINE_VAR constexpr bool is_same_v = is_same<_Ty, _Uty>::value;

// STRUCT TEMPLATE remove_const
template <class _Ty>
struct remove_const { // remove top level const qualifier
    using type = _Ty;
};

template <class _Ty>
struct remove_const<const _Ty> { // remove top level const qualifier
    using type = _Ty;
};

template <class _Ty>
using remove_const_t = typename remove_const<_Ty>::type;

// STRUCT TEMPLATE remove_volatile
template <class _Ty>
struct remove_volatile { // remove top level volatile qualifier
    using type = _Ty;
};

template <class _Ty>
struct remove_volatile<volatile _Ty> { // remove top level volatile qualifier
    using type = _Ty;
};

template <class _Ty>
using remove_volatile_t = typename remove_volatile<_Ty>::type;

// STRUCT TEMPLATE remove_cv
template <class _Ty>
struct remove_cv { // remove top level const and volatile qualifiers
    using type = _Ty;
};

template <class _Ty>
struct remove_cv<const _Ty> { // remove top level const and volatile qualifiers
    using type = _Ty;
};

template <class _Ty>
struct remove_cv<volatile _Ty> { // remove top level const and volatile qualifiers
    using type = _Ty;
};

template <class _Ty>
struct remove_cv<const volatile _Ty> { // remove top level const and volatile qualifiers
    using type = _Ty;
};

template <class _Ty>
using remove_cv_t = typename remove_cv<_Ty>::type;

// STRUCT TEMPLATE _Is_integral
template <class _Ty>
struct _Is_integral : false_type { // determine whether _Ty is integral
};

template <>
struct _Is_integral<bool> : true_type { // determine whether _Ty is integral
};

template <>
struct _Is_integral<char> : true_type { // determine whether _Ty is integral
};

template <>
struct _Is_integral<unsigned char> : true_type { // determine whether _Ty is integral
};

template <>
struct _Is_integral<signed char> : true_type { // determine whether _Ty is integral
};

#ifdef _NATIVE_WCHAR_T_DEFINED
template <>
struct _Is_integral<wchar_t> : true_type { // determine whether _Ty is integral
};
#endif // _NATIVE_WCHAR_T_DEFINED

template <>
struct _Is_integral<char16_t> : true_type { // determine whether _Ty is integral
};

template <>
struct _Is_integral<char32_t> : true_type { // determine whether _Ty is integral
};

template <>
struct _Is_integral<unsigned short> : true_type { // determine whether _Ty is integral
};

template <>
struct _Is_integral<short> : true_type { // determine whether _Ty is integral
};

template <>
struct _Is_integral<unsigned int> : true_type { // determine whether _Ty is integral
};

template <>
struct _Is_integral<int> : true_type { // determine whether _Ty is integral
};

template <>
struct _Is_integral<unsigned long> : true_type { // determine whether _Ty is integral
};

template <>
struct _Is_integral<long> : true_type { // determine whether _Ty is integral
};

template <>
struct _Is_integral<unsigned long long> : true_type { // determine whether _Ty is integral
};

template <>
struct _Is_integral<long long> : true_type { // determine whether _Ty is integral
};

// STRUCT TEMPLATE is_integral
template <class _Ty>
struct is_integral : _Is_integral<remove_cv_t<_Ty>>::type { // determine whether _Ty is integral
};

template <class _Ty>
_INLINE_VAR constexpr bool is_integral_v = is_integral<_Ty>::value;

// STRUCT TEMPLATE _Is_floating_point
template <class _Ty>
struct _Is_floating_point : false_type { // determine whether _Ty is floating point
};

template <>
struct _Is_floating_point<float> : true_type { // determine whether _Ty is floating point
};

template <>
struct _Is_floating_point<double> : true_type { // determine whether _Ty is floating point
};

template <>
struct _Is_floating_point<long double> : true_type { // determine whether _Ty is floating point
};

// STRUCT TEMPLATE is_floating_point
template <class _Ty>
struct is_floating_point : _Is_floating_point<remove_cv_t<_Ty>>::type { // determine whether _Ty is floating point
};

template <class _Ty>
_INLINE_VAR constexpr bool is_floating_point_v = is_floating_point<_Ty>::value;

// STRUCT TEMPLATE is_arithmetic
template <class _Ty>
struct is_arithmetic
    : bool_constant<is_integral_v<_Ty> || is_floating_point_v<_Ty>> { // determine whether _Ty is an arithmetic type
};

template <class _Ty>
_INLINE_VAR constexpr bool is_arithmetic_v = is_arithmetic<_Ty>::value;

// STRUCT TEMPLATE remove_reference
template <class _Ty>
struct remove_reference { // remove reference
    using type = _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&> { // remove reference
    using type = _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&&> { // remove rvalue reference
    using type = _Ty;
};

template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;

template <class _Ty>
using _Remove_cvref_t = remove_cv_t<remove_reference_t<_Ty>>;

#if _HAS_CXX20
template <class _Ty>
using remove_cvref_t = _Remove_cvref_t<_Ty>;

template <class _Ty>
struct remove_cvref { // defer evaluation of remove_cvref_t
    using type = remove_cvref_t<_Ty>;
};
#endif // _HAS_CXX20

_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // RC_INVOKED
#endif // _XTR1COMMON_

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */
